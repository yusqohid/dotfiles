{"version":3,"file":"main.js","mappings":"qBAAA,SAASA,EAAoBC,GAC5B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBF,EAAM,KAEjD,MADAC,EAAEE,KAAO,mBACHF,CACP,CACAF,EAAoBK,KAAO,IAAM,GACjCL,EAAoBM,QAAUN,EAC9BA,EAAoBO,GAAK,IACzBC,EAAOC,QAAUT,C,UCRjB,SAASA,EAAoBC,GAC5B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBF,EAAM,KAEjD,MADAC,EAAEE,KAAO,mBACHF,CACP,CACAF,EAAoBK,KAAO,IAAM,GACjCL,EAAoBM,QAAUN,EAC9BA,EAAoBO,GAAK,IACzBC,EAAOC,QAAUT,C,GCPbU,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaJ,QAGrB,IAAID,EAASE,EAAyBE,GAAY,CAGjDH,QAAS,CAAC,GAOX,OAHAM,EAAoBH,GAAUJ,EAAQA,EAAOC,QAASE,GAG/CH,EAAOC,OACf,CCrBAE,EAAoBK,EAAKR,IACxB,IAAIS,EAAST,GAAUA,EAAOU,WAC7B,IAAOV,EAAiB,QACxB,IAAM,EAEP,OADAG,EAAoBQ,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,CAAM,ECLdN,EAAoBQ,EAAI,CAACV,EAASY,KACjC,IAAI,IAAIC,KAAOD,EACXV,EAAoBY,EAAEF,EAAYC,KAASX,EAAoBY,EAAEd,EAASa,IAC5EE,OAAOC,eAAehB,EAASa,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDX,EAAoBY,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFlB,EAAoBsB,EAAKxB,IACH,oBAAXyB,QAA0BA,OAAOC,aAC1CX,OAAOC,eAAehB,EAASyB,OAAOC,YAAa,CAAEC,MAAO,WAE7DZ,OAAOC,eAAehB,EAAS,aAAc,CAAE2B,OAAO,GAAO,E,mCCLzBC,QAAQ,0CCARA,QAAQ,iCCARA,QAAQ,0CCARA,QAAQ,wCCARA,QAAQ,mDCARA,QAAQ,wCCARA,QAAQ,yCCARA,QAAQ,sCPA7C,MQAM,EAA+BA,QAAQ,MCatC,SAASC,EACdC,GAEA,OAAOA,EAAYC,QACjB,CAACC,EAAKC,KACJ,MAAMC,EACW,WAAfC,EAAAA,EAAAA,YAAyBF,EAAWG,KAAQ,UAASH,EAAWG,OAwClE,OAtCAJ,EAAI,GAAGK,KAAK,CACVC,GAAI,CACFC,WAAY,CAAEC,QAAS,CAAEC,MAAOR,EAAWS,OAC3CC,SAAU,CAAC,YAEbC,KAAM,CACJL,WAAY,CACVM,QAAS,CACPC,KAAMZ,GAERa,eAAgB,CACdC,qBAAsB,CACpBF,KAAMZ,EACNS,SAAU,SAMpBX,EAAI,GAAGK,KAAK,CACVC,GAAI,CACFC,WAAY,CAAEU,SAAU,CAAER,MAAOR,EAAWS,OAC5CC,SAAU,CAAC,aAEbC,KAAM,CACJL,WAAY,CACVM,QAAS,CACPC,KAAMZ,GAERa,eAAgB,CACdC,qBAAsB,CACpBF,KAAMZ,EACNS,SAAU,SAMbX,CAAG,GAEZ,CAAC,GAAI,IAET,CC/DqCJ,QAAQ,uCCARA,QAAQ,oCCARA,QAAQ,6CCARA,QAAQ,qCCARA,QAAQ,wCCARA,QAAQ,4CCctC,SAASsB,EACdC,GAEA,MAAMC,EAAiBrC,OAAOsC,QAAQF,EAAEG,UAAY,CAAC,GAAGC,MACtD,CAACC,EAAUC,IAAaD,EAAS,GAAGE,cAAcD,EAAS,MAG7D,OADAN,EAAEG,SAAWvC,OAAO4C,YAAYP,GACzBD,CACT,CAEO,SAASS,EACdzC,EACAN,GAEA,OAAOA,KAAOM,CAChB,CAEO,SAAS0C,EAAYC,EAAiBC,GAC3C,GAAIA,aAAerE,MAAO,CACxB,MAAMsE,EAAeD,EACrB,MAAQ,GAAED,MAAYE,EAAMF,YAAYE,EAAMC,OAChD,CAAO,MAAmB,iBAARF,EACR,GAAED,MAAYC,IACbA,EACD,GAAED,MAAYC,EAAIG,aAErBJ,CACT,CCzCA,MAAM,EAA+BlC,QAAQ,QCARA,QAAQ,4CAA7C,MCAM,EAA+BA,QAAQ,eCEtCuC,eAAeC,EAAgBC,GACpC,IACE,aAAcC,EAAAA,EAAAA,MAAKD,IAAWE,aAGhC,CAFE,MAAAC,GACA,OAAO,CACT,CACF,CCRA,MAAM,EAA+B5C,QAAQ,kBCAvC,EAA+BA,QAAQ,mBCAvC,EAA+BA,QAAQ,gBCMvC6C,EAAY,IAAIC,EAAAA,UAAU,CAAEC,OAAMA,EAAAA,gBAC3BC,EAAU,IAAIC,EAAAA,QAAQJ,GAEtBK,EAAwC,CAAC,EAyB/C,SAASC,EAAeV,EAAkBW,EAAU,IACzD,MAAMC,EAAe7C,EAAAA,KAAU4C,EAASX,GACxC,cAAcS,EAAaG,EAC7B,CAEOd,eAAee,EACpBb,EACAW,EAAU,IAEV,IAAKX,EACH,MAAO,CACLjC,KAAM,GACN+C,KAAM,CAAC,GAGX,IAAIF,EAAe7C,EAAAA,KAAU4C,EAASX,GAClCY,EAAaG,WAAW,aAC1BH,EAAeA,EAAaI,QAAQ,UAAW,KAEjD,IACE,MAAMC,QAAcV,EAAQW,YAAYN,GACU,IAAAO,EAAlD,GAAIV,EAAaG,IAAiBK,EAAMG,SAEtC,OADAX,EAAYU,EAACP,KAAbH,EAAYU,SA7CXrB,eAAgCE,GACrC,MAAMqB,QAAgBd,EAAQe,gBAAgBtB,EAAU,QACxD,IACE,OAAOuB,KAAKC,MAAMH,EAiBpB,CAhBE,MAAAlB,GACA,MAAMsB,EAAuB,GACvBC,GAASC,EAAAA,EAAAA,OAAUN,EAASI,GAElC,GAAIA,EAAOG,OAAS,EAClB,IAAK,MAAM,MAAEjC,EAAK,OAAEkC,KAAYJ,GAUlC,OAAOC,CACT,CACF,CAwB2CI,CAAiBlB,IAC/C,CACL7C,KAAM6C,EACNE,KAAML,EAAaG,GAKvB,CAFA,MAAOxF,GAEP,CAGF,MAAO,CACL2C,KAAM6C,EACNE,KAAM,CAAC,EAEX,CCpEOhB,eAAeiC,EAAeC,GACnC,MAAM,KAAElB,SAAeD,GACrBoB,EAAAA,EAAAA,MAAKD,EAAa,iBAEpB,MAAO,CACLA,cACAE,YAAapB,EAAKzC,KAClB8D,YAAarB,EAEjB,CCVOhB,eAAesC,EAAWpC,GAC/B,IACE,aAAcC,EAAAA,EAAAA,MAAKD,IAAWoB,QAGhC,CAFE,MAAAjB,GACA,OAAO,CACT,CACF,CCJA,IAAIkC,EAEJvC,eAAewC,EAAWC,GACxB,MAAMC,EAAa,CAAC,OAAQ,OAC5B,IAAK,MAAMC,KAAOD,EAChB,IACE,MAAME,EAAY,OAAMD,IAClBE,GAAUV,EAAAA,EAAAA,MAAKM,EAAeG,GACpC,SAAUN,EAAWO,GACnB,OAAOA,CAIX,CAFE,MAAAxC,GACA,MACF,CAEJ,CAEAL,eAAe8C,EAAOL,GACpB,MAAMI,QAAgBL,EAAWC,GACjC,GAAKI,EAAL,CAIA,IAAKN,EAAS,CAEZ,MAAMQ,EAAMtF,EAAAA,IAAAA,CAAQoF,GACpBE,EAAIC,QACJT,EAAUQ,CACZ,CAEA,OAAOR,CATP,CAUF,CAEOvC,eAAeiD,EAAiBR,GACrC,IAEE,eADmBD,EAAWC,GAIhC,CAFE,MAAAS,GACA,OAAO,CACT,CACF,CAgCOlD,eAAemD,EACpBV,EACAW,GAEA,IAAI,IAAAC,EACF,MAAMN,QAAYD,EAAOL,GAEzB,IAAKM,EACH,OAGF,IAAI9E,EAC2D,OAD/CoF,EACdN,EAAIO,qBAAqBF,EAAgBX,EAAgB,MAAIY,EAAI,GACjC,IAAAE,EAAlC,GAAItF,EAAKuF,SAAS,eAChBvF,EAAiC,OAA7BsF,EAAqB,MAAlBR,EAAIU,oBAAc,EAAlBV,EAAIU,eAAiBxF,IAAKsF,EAAI,GAGvC,OAAOtF,CAGT,CAFE,MAAAyF,GACA,MACF,CACF,CC9EO1D,eAAe2D,EACpBlB,EACAmB,EACAzE,GAEA,MAAM0E,EAAyB,GAY/B,OAVAA,EAAa3F,cAiEf8B,eACEyC,EACAqB,EACA3E,GAEA,IAAKA,EACH,MAAO,GAIT,GAAI2E,EAAQC,MAAQ,GAClB,MAAO,GAGT,MAAMC,EAAWpH,OAAOqH,OAAO9E,GAAU+E,KACtCC,GAAa,GAAE1B,KAAiB0B,EAAQC,sBAGrCC,EAA6B,GAEnC,IAAK,MAAMC,KAAON,EAChB,WACyB7D,EAAAA,EAAAA,MAAKmE,IACfhD,UACX+C,EAAiBnG,KAAKoG,EAAIpD,QAAQ,gBAAiB,IAGrD,CADA,MAAAgC,GACA,CAIJ,OAAOmB,CACT,CAhGcE,CAAkB9B,EAAemB,EAAWzE,UAG9C8D,EAAiBR,IACzBoB,EAAa3F,cDeV8B,eAA+ByC,GACpC,MAAMM,QAAYD,EAAOL,GAEzB,IAAKM,EACH,MAAO,GAGTA,EAAIyB,eAEJ,MAAMX,EAAe,GACrB,IAAK,MAAMY,KAAW1B,EAAI2B,yBAA0B,CAClD,MAAMJ,EAAMvB,EAAI4B,sBAAsBF,GACtC,GAAQ,MAAHH,GAAAA,EAAKM,oBAGV,IAAK,MAAOrG,EAAMsG,KAAsC,OAA5BC,EAAO,MAAHR,OAAG,EAAHA,EAAKM,qBAAmBE,EAAI,CAAC,EAAG,KAAAA,EAE9D,GAAkB,OAAdD,EAAoB,SACxB,IAAKE,MAAMC,QAAQH,IAAcA,EAAU5D,WAAW,cACpD,SAEF,MAAMhD,QAAakF,EAAkBV,EAAelE,GAChDN,GACF4F,EAAa3F,KAAKD,EAEtB,CACF,CACA,OAAO4F,CACT,CC3CgCoB,CAAgBxC,IAG9CoB,EAAa3F,cCxBR8B,eAA+ByC,GACpC,MAAMyC,GAAc/C,EAAAA,EAAAA,MAAKM,EAAe,gBAClC0C,GAA0BhD,EAAAA,EAAAA,MAC9BM,EACA,MACA,eACA,gBAGF,IAAI2C,EAAiBF,EAErB,MAAMG,EAAgB,GACtB,IACE,WAAYlF,EAAAA,EAAAA,MAAK+E,IAAc9E,cAC7B,OAAOiF,CAYX,CAVE,MAAAhF,GACA,IACE,WAAYF,EAAAA,EAAAA,MAAKgF,IAA0B/E,cACzC,OAAOiF,EAEPD,EAAiBD,CAIrB,CAFE,MAAAjC,GACA,OAAOmC,CACT,CACF,CAEA,MAAMC,QAAoBC,EAAAA,EAAAA,SAAQH,GAElC,IAAK,MAAMI,KAAqBF,EAC1BE,EAAkBvE,WAAW,aAINd,EAAAA,EAAAA,OAAKgC,EAAAA,EAAAA,MAAKiD,EAAgBI,KACnCpF,gBAIdoF,EAAkBvE,WAAW,YACxBsE,EAAAA,EAAAA,UAAQpD,EAAAA,EAAAA,MAAKiD,EAAgBI,KAAqBC,SAASC,IAChEL,EAAInH,KAAM,GAAEkH,KAAkBI,KAAqBE,IAAI,IAGzDL,EAAInH,KAAM,GAAEkH,KAAkBI,MAIlC,OAAOH,CACT,CD1B8BM,CAAgBlD,IAErCoB,CACT,CAEO7D,eAAe4F,EACpBnD,EACAoD,GAEA,GAAIA,EAAwB5E,WAAW,KACrC,OAAOkB,EAAAA,EAAAA,MAAKM,EAAeoD,GAG7B,SAAU5C,EAAiBR,GACzB,OAAOU,EAAkBV,EAAeoD,GAG1C,MAAMC,GAAkB3D,EAAAA,EAAAA,MACtBM,EACA,eACAoD,GAEIE,GAAmB5D,EAAAA,EAAAA,MACvBM,EACA,MACA,eACA,eACAoD,GAGF,IACE,aAAU5F,EAAgB6F,GACjBA,QACQ7F,EAAgB8F,GACxBA,OAEP,CAIJ,CAFE,MAAA1F,GACA,MACF,CACF,CEhEOL,eAAegG,EACpBvD,EACAvC,GAEA,MAAM+F,EAAaC,IAAiB/D,EAAAA,EAAAA,MAAK+D,EAAMhG,GAEzCiG,QAA2BP,EAAwBnD,EAAe,MACxE,GAAI0D,EAAoB,CACtB,MAAMlI,EAAOgI,EAAUE,GACvB,SAAU7D,EAAWrE,GACnB,OAAOA,CAEX,CAEA,MAAMmI,QAA6BR,EACjCnD,EACA,mBAEF,GAAI2D,EAAsB,CACxB,MAAMnI,EAAOgI,EAAUG,GACvB,SAAU9D,EAAWrE,GACnB,OAAOA,CAEX,CACF,CCnCA,MAAM,EAA+BR,QAAQ,UCA7C,MAAM,EAA+BA,QAAQ,yBCA7C,MAAM,EAA+BA,QAAQ,+BCGhC4I,EAAoB,oBACpBC,EAAoB,oBAE1B,IAAKC,EAeL,SAASC,EACdC,GAEA,OAAOhH,EAAOgH,EAAQJ,EACxB,CAEO,SAASK,EACdD,GAEA,OAAOhH,EAAOgH,EAAQH,EACxB,EAZC,SAbWC,GAAAA,EAAc,YAAdA,EAAc,sBAAdA,EAAc,8BAAdA,EAAc,oBAAdA,EAAc,kBAAdA,EAAc,kCAAdA,EAAc,YAAdA,EAAc,sBAAdA,EAAc,sCAazB,CAbWA,IAAAA,EAAc,KCFnB,MAAMI,EAAmC,CAC9CC,KAAM,QACNC,MAAO,CACLD,KAAM,SACN,oBAAqBL,EAAepH,WAI3B2H,EAAsB,CACjCF,KAAM,QACNC,MAAO,CACLD,KAAM,SACN,oBAAqBL,EAAeQ,YAI3BC,EAAUpD,GAAuC,CAC5D,CAAEgD,KAAM,SAAU,oBAAqBL,EAAeU,mBACtD,CACEL,KAAM,SACNxI,WAAY,CACV8I,MAAO,CACLN,KAAM,SACN,oBAAqBL,EAAeY,WAEtChI,SAAUA,EAASyE,KAGvB,CACEgD,KAAM,SACNxI,WAAY,CACVgJ,QAAS,CACPR,KAAM,YAIZ,CACEA,KAAM,SACNxI,WAAY,CACViJ,QAAS,CACPT,KAAM,YAIZ,CACEA,KAAM,SACNxI,WAAY,CACVkJ,IAAK,CACHV,KAAM,aAMDW,EAAe3D,IAAoB,CAC9CgD,KAAM,SACN/H,qBAAsB,CACpB2I,MAAOR,EAAOpD,MAIL6D,EAAmB,CAC9Bb,KAAM,QACNC,MAAO,CACLD,KAAM,SACN,oBAAqBL,EAAekB,OAIlCtI,EAAYyE,GACZA,EAAUG,MAAQ,GACb,CACL6C,KAAM,SACNc,KAAM,CAAC,OAAQ,iBAGV,CACLF,MAAO,CACL,CACEZ,KAAM,SACN,oBAAqBL,EAAepH,UAEtC,CACEyH,KAAM,QACNC,MAAO,CACLD,KAAM,SACN,oBAAqBL,EAAepH,aAQnCwI,EAAUA,CACrB/D,EACAgE,KAE2B,CACzB/I,qBAAoBjC,OAAAiL,OAAA,CAClBjB,KAAM,SACNxI,WAAUxB,OAAAiL,OAAA,CACRf,WACIc,GAAa,CAAE9I,SAAU,CAAE8H,KAAM,WACjCgB,GAAa,CACfhJ,eAAgB,CAAEC,qBAAsB,CAAE+H,KAAM,YACjD,CACDkB,UAAW,CACTlB,KAAM,QACNC,MAAO,CACLW,MAAO,CACL,CACEZ,KAAM,SACN,oBAAqBL,EAAewB,iBAEtC,CACEnB,KAAM,SACNxI,WAAY,CACVe,SAAUA,EAASyE,GACnBoE,OAAQ,CACNpB,KAAM,SACN,oBAAqBL,EAAeoB,SAEtCM,OAAQ,CACNrB,KAAM,SACNc,KAAM,CAAC,SAAU,iBAO7BV,OAAQ,CACNJ,KAAM,QACNC,MAAO,CACLW,MAAOR,EAAOpD,QAIhBgE,GAAa,CAAEM,MAAON,MC/HzB,SAASO,EACdxK,EACAyK,EAAiC,CAAC,EAClCxE,GAEA,MAAO,CAAEgE,GAAalK,EAAiCC,GACjD0K,EAIR,SACET,EACAQ,EACAxE,GACoB,IAAA0E,EACpB,MAAMC,EAC+C,OADlCD,EAChBX,EAAQ/D,EAAWgE,GAAW/I,sBAAoByJ,EAAe,CAAC,EAC/DE,EAAoB5L,OAAOnB,KAAK2M,GAAgBxK,QACpD,CAAC+J,EAASK,KACR,MAAMS,EAAyCL,EAAeJ,GAC9D,IAAIU,EAA2BH,EAC/B,GAAY,MAARE,GAAAA,EAAU3J,SAAU,CACtB,MAAM6J,EAAQf,EAAUgB,MAAMnC,IAAW,IAAAoC,EACvC,MAAMC,EAAOrC,EAAOtI,GACdW,EAAe,MAAJgK,GAAgB,OAAZD,EAAJC,EAAM1K,iBAAF,EAAJyK,EAAkB/J,SACnC,OAAe,MAARA,OAAQ,EAARA,EAAUR,SAAUmK,EAAS3J,QAAQ,IAE1C6J,IACFD,EAAe,CACbvK,GAAI,CACFC,WAAY,CAAEU,SAAU,CAAE8H,KAAM,WAChCpI,SAAU,CAAC,aAEbC,KAAM8J,EACNQ,KAAMJ,EAAMlK,MAGlB,CAEA,OADAkJ,EAAQK,GAAUU,EACXf,CAAO,GAEhB,CAAC,GAEH,MAAO,CACLf,KAAM,SACNxI,WAAY,CACV4K,WAAY,CACVpC,KAAM,SACN,oBAAqBL,EAAeQ,WAEtCJ,qBAAoB,EACpBc,KAAI,EACJF,YAAaA,EAAY3D,GACzB+D,QAAS,CACPf,KAAM,SACNxI,WAAYoK,EACZ3J,qBAAsB0J,IAI9B,CAtDmBU,CAAiBrB,EAAWQ,EAAgBxE,GAC7D,OAAOyE,CACT,CCfO,SAASa,EAAqBtF,GACnC,MAAMyE,EAIR,SAA0BzE,GACxB,MAAO,CACLgD,KAAM,SACNxI,WAAY,CACV+K,GAAI,CACFvC,KAAM,SACNxI,WAAY,CACVgL,OAAQ,CACNxC,KAAM,WAERW,YAAaA,EAAY3D,GACzB6D,KAAI,EACJd,qBAAoB,EACpBgB,QAASA,EAAQ/D,MAK3B,CAtBmBqF,CAAiBrF,GAClC,OAAOyE,CACT,CCFO,SAASgB,EACd1L,EACAwB,EACAyE,GAEA,MAAO,CAAEgE,GAAalK,EAAiCC,GACjDgK,EAsER,SAAoBxI,GAClB,MAAMsI,EAAO,IAAI6B,IAEjB,IAAK,MAAMC,KAAwB3M,OAAOqH,OAAO9E,GAC/C,IAAK,MAAM6I,KAAUpL,OAAOnB,KAAiC,OAA7B+N,EAACD,EAAqB5B,SAAO6B,EAAI,CAAC,GAAI,KAAAA,EACpE/B,EAAKgC,IAAIzB,EACX,CAGF,OAAOjD,MAAM2E,KAAKjC,EACpB,CAhFkBkC,CAAWxK,GAE3B,OADiB8J,EAAiBrB,EAAWD,EAAS/D,EAExD,CAEA,SAASqF,EACPrB,EACAgC,EACAhG,GACoB,IAAA0E,EACpB,MAAMC,EAC+C,OADlCD,EAChBX,EAAQ/D,EAAWgE,GAAW/I,sBAAoByJ,EAAe,CAAC,EACrE,MAAO,CACL1B,KAAM,SACNxI,WAAY,CACVyL,mBAAoB,CAClBjD,KAAM,SACN/H,qBAAsB,CACpB+H,KAAM,SACNxI,WAAY,CACVM,QAAS,CACPkI,KAAM,SACNxI,WAAY,CACV0L,oBAAqB,CACnBlD,KAAM,QACNC,MAAO,CACLD,KAAM,SACN,oBAAqBL,EAAeoB,eAQlDS,eAAgB,CACdxB,KAAM,SACNxI,WAAYwL,EAAehM,QAAsB,CAACC,EAAKkM,KACrDlM,EAAIkM,GAAQnN,OAAAiL,OAAA,CACVjB,KAAM,UACH2B,GAEE1K,IACN,CAAC,IAENmM,uBAAwB,CACtBpD,KAAM,QACNC,MAAO,CACLW,MAAO,CACL,CACEZ,KAAM,SACN,oBAAqBL,EAAewB,iBAEtC,CACEnB,KAAM,SACNxI,WAAY,CACV4J,OAAQ,CACNpB,KAAM,SACNqD,YAAa,0BACb,oBAAqB1D,EAAeoB,eAStD,CC5EO,SAASuC,EAAeC,GAC7B,MAAsB,cAAX,MAAJA,OAAI,EAAJA,EAAMvD,KACf,CAEO,SAASwD,EAAaD,GAC3B,MAAsB,YAAX,MAAJA,OAAI,EAAJA,EAAMvD,KACf,CAEO,SAASyD,EAAaF,GAC3B,MAAsB,YAAX,MAAJA,OAAI,EAAJA,EAAMvD,KACf,CAEO,SAAS0D,EAAYH,GAC1B,MAAsB,WAAX,MAAJA,OAAI,EAAJA,EAAMvD,KACf,CChBA,MAAM2D,EAAuB,IAAIC,IAyC1B,SAASC,EACdN,GAEA,MAAMO,EAASP,EAAKO,OACpB,GAAIR,EAAeQ,IAAWL,EAAaK,EAAOC,SAAU,CAC1D,MAAMjO,EAAMgO,EAAOC,QAAQnN,MAAMoN,cACjC,OAAOL,EAAqBxN,IAAIL,EAClC,CAGF,CAEO,SAASmO,EAAyBV,GACvC,MAAMO,EAASP,EAAKO,OACpB,GAAIR,EAAeQ,IAAWL,EAAaK,EAAOC,SAAU,CAC1D,MAAMjO,EAAMgO,EAAOC,QAAQnN,MAAMoN,cACjC,OAAOL,EAAqBO,IAAIpO,EAClC,CAEA,OAAO,CACT,CA3DA6N,EAAqBQ,IAAI,aAAc,CACrCC,KAAM,uBACNC,eAAgB1E,EAAe2E,OAEjCX,EAAqBQ,IAAI,QAAS,CAChCC,KAAM,SACNC,eAAgB1E,EAAe2E,OAEjCX,EAAqBQ,IAAI,YAAa,CACpCC,KAAM,OACNC,eAAgB1E,EAAe2E,OAEjCX,EAAqBQ,IAAI,OAAQ,CAC/BC,KAAM,OACNC,eAAgB1E,EAAe2E,OAEjCX,EAAqBQ,IAAI,WAAY,CACnCC,KAAM,kBACNC,eAAgB1E,EAAe2E,OAEjCX,EAAqBQ,IAAI,aAAc,CACrCE,eAAgB1E,EAAeQ,YAEjCwD,EAAqBQ,IAAI,gBAAiB,CACxCE,eAAgB1E,EAAe4E,gBAEjCZ,EAAqBQ,IAAI,eAAgB,CACvCE,eAAgB1E,EAAe4E,gBAEjCZ,EAAqBQ,IAAI,cAAe,CACtCE,eAAgB1E,EAAe4E,gBAEjCZ,EAAqBQ,IAAI,SAAU,CACjCE,eAAgB1E,EAAe4E,gBAEjCZ,EAAqBQ,IAAI,kBAAmB,CAC1CE,eAAgB1E,EAAe4E,gBC5CjC,MAAM,GAA+B1N,QAAQ,QCARA,QAAQ,sCCG7C,IAAI2N,GAUG,MAAMC,GAAoB,CAC/BD,IAAIzL,KAAoB2L,GACnB,MAAHF,IAAAA,GACG,YAAW,IAAIG,KAAKA,KAAKC,OAAOC,mBAAmB9L,SACjD2L,EAEP,GCEKtL,eAAe0L,GACpBjJ,EACAkJ,GAEA,MAAMC,QAAmB5F,EACvBvD,GACAN,EAAAA,EAAAA,MAAK,MAAO,QAAS,cAGvB,GAAKyJ,EAIL,OAAOC,GAAaD,EAAYD,EAClC,CAEO3L,eAAe8L,GACpBrJ,EACAkJ,GAEA,IAAIC,QAAmB5F,EACrBvD,GACAN,EAAAA,EAAAA,MAAK,MAAO,gBAAiB,qBAU/B,OAPKyJ,IACHA,QAAmB5F,EACjBvD,GACAN,EAAAA,EAAAA,MAAK,MAAO,OAAQ,gBAAiB,sBAIlC0J,GAAaD,EAAYD,EAClC,CAKO3L,eAAe+L,GACpBtJ,EACAkJ,GAEA,IAAIC,QAAmB5F,EACrBvD,GACAN,EAAAA,EAAAA,MAAK,MAAO,gBAAiB,kBAU/B,OAPKyJ,IACHA,QAAmB5F,EACjBvD,GACAN,EAAAA,EAAAA,MAAK,MAAO,OAAQ,mBAIjB0J,GAAaD,EAAYD,EAClC,CAEA3L,eAAe6L,GACbD,EACAD,GAEA,IAAKC,EAIH,MAHM,MAAND,GAAAA,EAAQP,IACL,sBAAqBQ,sGAElB,gCAGW,WAAf5N,EAAAA,EAAAA,cACF4N,EAAaA,EAAW1K,QAAQ,MAAO,MAIzC,MAAM8K,EAAWvO,EAAAA,IAAAA,CAAQmO,GAIzB,OAFM,MAAND,GAAAA,EAAQP,IAAK,6BAA4BQ,KAElCI,CACT,CCnGA,MAAM,GAA+BvO,QAAQ,cCkB7C,ICfIwO,GDeAC,GAAoC,KAEjClM,eAAemM,GACpB1J,EACAmB,EACA+H,GAKA,MAAMS,EAAQC,GAAAA,YAAAA,MAGd,GAFAV,EAAOP,IAAI,sCAEPxH,EAAUG,MAAQ,GAEpB,OADAsH,GAAUD,IAAI,iCACPkB,GAAqB7J,GAG9B,IAEG8J,QAAQjF,IAAYkF,IAAK,EACzBD,QAAQjF,IAAYmF,uBAAwB,EAC5CF,QAAQjF,IAAYoF,uBAAyBjK,EAC9C,MAAOkK,EAAoBC,EAAgBC,SAAkBC,QAAQC,IAAI,CACvEhB,GAA+BtJ,EAAekJ,GAC9CG,GAAkBrJ,EAAekJ,GACjCD,GAAYjJ,EAAekJ,KAG7B,IAAIqB,EACJ,IACEA,EAAyBL,EAAmBM,oBAAoB,CAC9DC,OAAQ,KACRjP,KAAMwE,GAMV,CAJE,MAAApC,GACAsL,EAAOP,IAAI,6DACX4B,SAAgCV,GAAqB7J,IAClDuK,sBACL,CAEA,IACET,QAAQY,KAAO,SAAU3R,GACvB4R,QAAQC,KAAK,gCAAiC7R,EAChD,OAEiBU,IAAb2Q,IACFA,EAASS,OAAOzN,MAASyN,OAKvB1J,EAAUG,MAAQ,GACpBmI,GAAgBU,EAAuBW,sBAEvClC,GAAUD,IAAI,2BACdc,SAAqBU,EAAeY,wBAAwB,CAC1DC,aAAa,EACbC,mBAAmB,IAErBrC,GAAUD,IAAI,sCAKlB,CAHE,MAAO9P,GACP+P,GAAUD,IAAI,+BACdC,GAAUD,IAAI9P,EAAEwE,MAClB,CAEAkN,EAuCJ,SACEA,EACAd,GAEA,IAAKA,EACH,OAAOc,EAIT,MAAMW,EAAwD/Q,OAAAiL,OAAA,GACzDmF,EAAsB,CACzB7N,SAAU,CAAC,IAGb,IAAK,MAAOyO,EAAazD,KAASvN,OAAOsC,QAAQgN,EAAa2B,OAAQ,CACpE,MAAMC,EAAmBd,EAAuB7N,SAASyO,GAEzD,GAAKE,EAeE,KAAAC,EAAAC,EACLL,EAA+BxO,SAASyO,GAAYhR,OAAAiL,OAAA,GAC/CiG,EAAgB,CACnBnG,QAA0B,OAAnBoG,EAAE5D,EAAK8D,KAAKtG,SAAOoG,EAAI,CAAC,EAC/BG,MAAsB,OAAjBF,EAAE7D,EAAK8D,KAAKC,OAAKF,EAAI,GAC1BzP,KAAMqP,GAEV,KAtBuB,KAAAO,EAAAC,EAAAC,EAIrB,GAAIT,EAAYjF,MAAM,KACpB,SAGFgF,EAA+BxO,SAASyO,GAAe,CACrDxJ,KAAM+F,EAAK8D,KAAK7J,KAChBuD,QAA0B,OAAnBwG,EAAEhE,EAAK8D,KAAKtG,SAAOwG,EAAI,CAAC,EAC/B5P,KAAMqP,EACNnG,KAAoB,OAAhB2G,EAAEjE,EAAK8D,KAAKxG,MAAI2G,EAAI,GACxBF,MAAsB,OAAjBG,EAAElE,EAAK8D,KAAKC,OAAKG,EAAI,GAE9B,CAQF,CAEA,OAAOV,CACT,CAlF6BW,CACvBtB,EACAd,IAGF,MAAMqC,EAAMlC,GAAAA,YAAAA,MAGZ,OAFAV,EAAOP,IAAK,yCAAwCmD,EAAMnC,QAEnD,CACLY,yBAKJ,CAHE,MAAO1R,GAEP,OADA+P,GAAUD,IAAK,6CAA4C9P,KACpDgR,GAAqB7J,EAC9B,CACF,CAEAzC,eAAesM,GAAqBzL,GAAiB,IAAA2N,EACnD,MAAMC,SACE1N,EAAqB,iBAAkBF,IAC7CG,KAEI0N,SACE3N,EAAqB,UAAWF,IACtCG,KACF,MAAO,CACLgM,uBAAsBpQ,OAAAiL,OAAA,GACjB4G,EACAC,EAAM,CACTvP,SAAQvC,OAAAiL,OAAA,GAEsB,OAFtB2G,EAEDE,EAAevP,UAAQqP,EAAI,CAAC,EAC9BC,EAActP,YAGrBwP,YAAYxM,EAAAA,EAAAA,MAAKtB,EAAS,kBAE9B,CCtHA,IAAI+N,IAAkB,EAEtB,MAAMC,GAAgB,IAAIC,EAAAA,OAAO,SAE1B9O,eAAe+O,GAAatM,GACjC,IAAKmM,GAAiB,CACpB,MAAM1M,QAAoB8D,EAAkBvD,EAAe,gBAE3D,IAAKP,EACH,OAAO2M,GAGT5C,GAAyBxO,EAAAA,IAAAA,CAAQyE,GACjC0M,IAAkB,CACpB,CAEA,IAAK3C,GACH,OAAO4C,GAET,MAAMjL,GAAYoL,EAAAA,EAAAA,QAAO/C,GAAuBnI,SAChD,OAAKF,GACIiL,EAIX,CCbgD,IAErCI,IAAM,SAANA,GAAAA,EAAAA,EAAM,6BAANA,EAAAA,EAAM,6BAANA,EAAAA,EAAM,oBAANA,KAAAA,GAAM,KAMjB,IAAIC,GAAe,IAAIC,GAAAA,cACnBC,GAAiBH,GAAOI,YAUrBrP,eAAesP,GACpB7M,EACAkJ,EAAiB,CACfP,IAAIzL,GACFyN,QAAQhC,IAAIzL,EACd,GAEF4P,GAMA,OAJIA,GAjBN,SAAqB9M,GACnB2M,GAASH,GAAOI,YAChBH,GAAe,IAAIC,GAAAA,cAEnBvO,EAAe,iBAAkB6B,GACjC7B,EAAe,UAAW6B,EAC5B,CAYI+M,CAAY/M,IAGPgN,EAAAA,GAAAA,iBACLC,EAAAA,GAAAA,MACE,IAAMN,KAAWH,GAAOI,cACxBM,EAAAA,GAAAA,IAAG,CAAC,GAAGC,MACLC,EAAAA,GAAAA,MAAI,KACFT,GAASH,GAAOa,WAAW,KAE7BC,EAAAA,GAAAA,YAAU,KAAMrG,EAAAA,GAAAA,MAWxB1J,eACEyC,EACAkJ,GAEA,IAAI,IAAAqE,EAAAC,EACF,MAAMnM,QAAgBiL,GAAatM,GAC7ByN,QAAe/D,GAAqB1J,EAAeqB,EAAS6H,GAE5DwE,QAAgB7N,GAAWH,EAAAA,EAAAA,MAAKM,EAAe,eACrD,MAAO,CACL2N,oBAAoB,EACpBC,UAAWtR,EAAsBmR,EAAOlD,wBACxCsD,cAAeJ,EAAOI,cACtBH,UACAI,mBAAoBL,EAAOlD,uBAAuBwD,aAClDC,gBAAiB,CACfC,QAAsD,OAA/CV,EAAEE,EAAOlD,uBAAuByD,sBAAe,EAA7CT,EAA+CU,QACxDC,QAAsD,OAA/CV,EAAEC,EAAOlD,uBAAuByD,sBAAe,EAA7CR,EAA+CU,SAE1D/M,UAAW,CACTG,MAAOD,EAAQC,MACf6M,MAAO9M,EAAQ8M,MACfC,KAAM/M,EAAQA,SAEhBrB,gBA0BJ,CAxBE,MAAOnH,GAIP,OAHAqQ,EAAOP,IAAI1L,EAAY,oBAAqBpE,IAGrC,CACL8U,oBAAoB,EACpBC,UAAW,CACTS,SAAU,cACV3R,SAAU,CAAC,EACX2E,QAAS,GAEXrB,gBACA8N,kBAAkB,EAClB3M,UAAW,CACTG,MAAO,EACP6M,MAAO,EACPC,KAAM,SAERV,SAAS,EACTM,gBAAiB,CACfC,QAAS,OACTC,QAAS,QAGf,CACF,CA9D6BI,CAAWtO,EAAekJ,OAC/CkE,EAAAA,GAAAA,MAAKQ,IACHnB,GAAa8B,KAAKX,GAClBjB,GAASH,GAAOgC,MAAM,KAG1B/B,IAGN,CCzDO,SAASgC,GACdC,EACAlT,EACAkM,EACAiH,EACAC,EACAC,GAKA,MAAO,CACLH,MAFFA,EAAS,IAAGA,KAGVG,gBACAD,OACAE,WAAYJ,EACZK,iBAAkB,EAClBC,SAAU,CACRC,QAASP,EACTQ,MAAO,CACLvF,MAZgBgF,EAASQ,WAAWzH,EAAKpI,QAazCwM,IAZc6C,EAASQ,WAAWzH,EAAKpI,OAASoI,EAAKrI,UAezD+P,OAAQ5T,EAEZ,CCxBO+B,eAAe8R,GACpBC,EACA5H,EACAiH,EACAY,GAAmB,GAEnB,IAAKD,EACH,MAAO,GAGT,MAAMD,EAAwC,IAExC,UAAEzB,SAAoBf,GAAYyC,GAExC,IAAK,MAAM5K,KAAavK,OAAOnB,KAA0B,OAAtBwW,EAAC5B,EAAU9I,aAAW0K,EAAI,CAAC,GAAI,KAAAA,EAC5DD,GACFF,EAAoB5T,KAClBgT,GACG,IAAG/J,IACJ,GACAgD,EACAiH,EACAc,EAAAA,mBAAAA,SACC,SAAQ/K,sCAIf2K,EAAoB5T,KAClBgT,GACE/J,EACA,GACAgD,EACAiH,EACAc,EAAAA,mBAAAA,UAGN,CAEA,OAAOJ,CACT,CCxCO,SAASK,GAAgBhI,GAC9B,GAAIC,EAAaD,GACf,IAAK,MAAMiI,KAASjI,EAAKkI,SAAU,CAM7B,IAAAC,EALJ,GAAIpI,EAAekI,GACjB,IAC2B,SAAxBA,EAAMzH,QAAQnN,OACW,eAAxB4U,EAAMzH,QAAQnN,QAChB6M,EAAa+H,EAAMG,WAEnB,OAAsB,OAAtBD,EAAOF,EAAMG,gBAAS,EAAfD,EAAiB9U,KAG9B,CAGF,OAAI2M,EAAKO,OACAyH,GAAgBhI,EAAKO,QAGvB,EACT,CC5BA,MAAM,GAA+BjN,QAAQ,a,eCatCuC,eAAewS,GACpBT,EACA5H,EACAiH,EACA1S,GAMA,MAAMmI,EAA0B,GAEhC,IAAKkL,EACH,OAAOlL,EAGT,MAAM,sBAAE4L,EAAqB,KAAEzH,EAAI,WAAE0H,GAAY9V,OAAAiL,OAAA,CAC/C4K,uBAAuB,GACpB/T,GAGL,IAAK2L,EAAaF,GAChB,OAAOtD,EAGT,MAAM8L,EAAcR,GAAgBhI,GAE9B+D,QAAc0E,KAAS,CAACb,EAAc,OAAS/G,GAAO,CAC1D5B,OAAQ,CAAC,sBACTyJ,KAAK,EACLC,UAA0B,SAAfJ,EACXK,gBAAgC,cAAfL,EACjBM,YAAY,IAGRC,EACW,cAAfP,EACIR,EAAAA,mBAAAA,OACAA,EAAAA,mBAAAA,KAEN,IAAK,MAAMhH,KAAQgD,EAAO,CACxB,GACEuE,GACAvH,EAAKjN,KAAKgD,WAAW8Q,EAAc,IAAMY,GACzC,CACA,MAAMxB,EACJ,gBACAjG,EAAKjN,KAAKiD,QAAQ6Q,EAAc,IAAMY,EAAa,IAErD9L,EAAM3I,KACJgT,GAAqBC,EAAOjG,EAAKjN,KAAMkM,EAAMiH,EAAU6B,GAE3D,CAEA,GAAI/H,EAAKjN,KAAKgD,WAAW8Q,GAAc,CACrC,MAAMZ,EAAQjG,EAAKjN,KAAKiD,QAAQ6Q,EAAc,IAAK,IAEnD,GAAIU,EAAuB,CACzB,MAAMtB,EAAQ,kBAAoBjG,EAAKjN,KAAKiD,QAAQ6Q,EAAa,IACjElL,EAAM3I,KACJgT,GAAqBC,EAAOjG,EAAKjN,KAAMkM,EAAMiH,EAAU6B,GAE3D,MACEpM,EAAM3I,KACJgT,GAAqBC,EAAOjG,EAAKjN,KAAMkM,EAAMiH,EAAU6B,GAG7D,CACF,CAEA,OAAOpM,CACT,CC1EO7G,eAAekT,GACpBnB,EACA5H,EACAiH,GAEA,IAAKW,EACH,MAAO,GAGT,MAAMoB,EAAkC,IAElC,UAAE9C,SAAoBf,GAAYyC,GAClCtK,EAAO,IAAI6B,IACjB,IAAK,MAAMC,KAAwB3M,OAAOqH,OAAOoM,EAAUlR,UACzD,IAAK,MAAMiU,KAAgC,OAA7B5J,EAAID,EAAqB9B,MAAI+B,EAAI,GAAI,KAAAA,EACjD/B,EAAKgC,IAAI2J,EACX,CAGF,MAAMC,EAeR,SAA8BlJ,GAC5B,MAAMO,EAASP,EAAKO,OACpB,IAAKJ,EAAYI,GACf,OAAO,IAAIpB,IAGb,OAAO,IAAIA,IAAIoB,EAAO7D,MAAM3C,KAAKoP,GAASA,EAAK9V,QACjD,CAtBuB+V,CAAqBpJ,GAE1C,IAAK,MAAMiJ,KAAO3L,EACZ4L,EAAavI,IAAIsI,IAIrBD,EAAcjV,KACZgT,GAAqBkC,EAAK,GAAIjJ,EAAMiH,EAAUc,EAAAA,mBAAAA,WAIlD,OAAOiB,CACT,CChCOnT,eAAewT,GACpBzB,EACA5H,EACAiH,EACAY,GAAmB,GAEnB,IAAKD,EACH,MAAO,GAGT,MAAMyB,EAAsC,IACtC,UAAEnD,SAAoBf,GAAYyC,GAElC0B,EAAc,IAAInK,IACxB,IAAK,MAAMnF,KAAWvH,OAAOqH,OAAOoM,EAAUlR,UAC5C,IAAK,MAAMuU,KAAc9W,OAAOnB,KAAoB,OAAhBkY,EAACxP,EAAQwD,SAAOgM,EAAI,CAAC,GAAI,KAAAA,EAC3DF,EAAYhK,IAAIiK,EAClB,CAGF,MAAME,EAsCR,SAAiCzJ,GAC/B,MAAMO,EAASP,EAAKO,OACpB,IAAKJ,EAAYI,GACf,OAAO,IAAIpB,IAGb,OAAO,IAAIA,IAAIoB,EAAO7D,MAAM3C,KAAKoP,GAASA,EAAK9V,QACjD,CA7C0BqW,CAAwB1J,GAEhD,IAAK,MAAMuJ,KAAcD,EACvB,IAAIG,EAAgB9I,IAAI4I,GAAxB,CAIA,GAAI1B,EAAkB,CACpB,MAAM8B,EAAiB,IAAGJ,IAC1B,GAAIE,EAAgB9I,IAAIgJ,GACtB,SAGFN,EAAkBtV,KAChBgT,GACE4C,EACA,GACA3J,EACAiH,EACAc,EAAAA,mBAAAA,MACC,mCAAkCwB,kCAGzC,CACAF,EAAkBtV,KAChBgT,GACEwC,EACA,GACAvJ,EACAiH,EACAc,EAAAA,mBAAAA,OAzBJ,CA8BF,OAAOsB,CACT,CCvCOxT,eAAe+T,GACpBhC,EACAnO,EACAoQ,EACA5C,EACA6C,EACAC,GAEA,IAAKnC,EACH,MAAO,GAGT,MAAMhQ,EAASqP,EAAS+C,SAASD,GAC3B/J,EAAO6J,EAAQI,kBAAkBrS,GACvC,IAAKoI,EACH,MAAO,GAGT,MAAMtD,EA2CR,SACEkL,EACAnO,EACAuG,EACAiH,GAEA,OAAOpR,MACLqU,EACArJ,KAIA,MAAMyH,GAAwB,EAC9B,OAAQ4B,GACN,KAAK9N,EAAe2E,KAClB,OAAOsH,GAAeT,EAAa5H,EAAMiH,EAAU,CACjDpG,KAAU,MAAJA,EAAAA,EAAQ,MACd0H,WAAY,OACZD,0BAGJ,KAAKlM,EAAeQ,UAClB,OAAOyL,GAAeT,EAAa5H,EAAMiH,EAAU,CACjDpG,KAAU,MAAJA,EAAAA,EAAQ,IACd0H,WAAY,YACZD,0BAGJ,KAAKlM,EAAe4E,cAClB,OC5GDnL,eACL+R,EACA5H,EACAiH,GAEA,IAAKW,EACH,MAAO,GAGT,MAAM,UAAE1B,SAAoBf,GAAYyC,GAElCuC,EAA4C,GAE5CC,EAAqBrC,EAAAA,mBAAAA,MAE3B,IAAK,MAAOtE,EAAa4G,KAAkB5X,OAAOsC,QAChDmR,EAAUlR,UAEV,IAAK,MAAOuU,EAAY1L,KAAWpL,OAAOsC,QACnB,OAD0BuV,EAC/CD,EAAc7M,SAAO8M,EAAI,CAAC,GACzB,KAAAA,EACD,MAAMC,EAAe,GAAE9G,KAAe8F,IACtCY,EAAwBpW,KACtBgT,GACEwD,EACA,GACAvK,EACAiH,EACAmD,IAIJ,IAAK,MAAMC,KAAiB5X,OAAOnB,KAA0B,OAAtBkZ,EAAC3M,EAAOpJ,gBAAc+V,EAAI,CAAC,GAAI,KAAAA,EACpE,MAAMC,EAAsB,GAAEF,KAAeF,IAC7CF,EAAwBpW,KACtBgT,GACE0D,EACA,GACAzK,EACAiH,EACAmD,GAGN,CACF,CAGF,OAAOD,CACT,CD4DeA,CAAwBvC,EAAa5H,EAAMiH,GAEpD,KAAK7K,EAAepH,SAClB,OE/GDa,eACL+R,EACA5H,EACAiH,GAEA,IAAKW,EACH,MAAO,GAGT,MAAM,UAAE1B,SAAoBf,GAAYyC,GAElC8C,EAAsC,GAE5C,IAAK,MAAMjH,KAAehR,OAAOnB,KAAK4U,EAAUlR,UAC9C0V,EAAkB3W,KAChBgT,GACEtD,EACA,GACAzD,EACAiH,EACAc,EAAAA,mBAAAA,QAEFhB,GACG,IAAGtD,IACJ,GACAzD,EACAiH,EACAc,EAAAA,mBAAAA,OACC,YAAWtE,wCAKlB,OAAOiH,CACT,CF6EeA,CAAkB9C,EAAa5H,EAAMiH,GAE9C,KAAK7K,EAAekB,KAClB,OAAOyL,GAAenB,EAAa5H,EAAMiH,GAE3C,KAAK7K,EAAeoB,QAClB,OAAO6L,GAAkBzB,EAAa5H,EAAMiH,GAE9C,KAAK7K,EAAewB,gBAClB,OAAOyL,GAAkBzB,EAAa5H,EAAMiH,GAAU,GAExD,KAAK7K,EAAeY,UAClB,OAAO2K,GAAoBC,EAAa5H,EAAMiH,GAEhD,KAAK7K,EAAeU,kBAClB,OAAO6K,GAAoBC,EAAa5H,EAAMiH,GAAU,GAE1D,QACE,MAAO,GACR,CAGP,CAjGgB0D,CAAgB/C,EAAanO,EAAWuG,EAAMiH,GAE5D,IAAI2D,EAAkC,GAEtC,IAAK,MAAM,OAAEtO,EAAQ0D,KAAM6K,KAAgBf,EAGzC,GAAIe,GAAc7K,GACZ3D,EAAkBC,GAAS,CAC7B,MAAM4N,EAAa5N,EAAOJ,GAC1B,GAAIK,EAAkBD,GAAS,CAC7BsO,QAAsBlO,EAAMwN,EAAY5N,EAAOH,IAC/C,KACF,CAEAyO,QAAsBlO,EAAMwN,GAC5B,KACF,CAIJ,MAAMY,EAAoBxK,EAAyBN,GAUnD,GARI8K,GAA8C,IAAzBF,EAAcjT,SACrCiT,QAAsBlO,EACpBoO,EAAkBhK,eAClBgK,EAAkBjK,OAKlBV,EAAYH,EAAKO,QAAS,CAC5B,MAAMwK,EAAgB/K,EAAKO,OAAO2H,SAASnO,KAAKiR,GAC9C1T,KAAK2T,UAAUD,EAAE3X,SAEnBuX,EAAgBA,EAAcM,QAC3BC,IAAkBJ,EAAc1R,SAAS8R,EAAanE,QAE3D,CAEA,OAAO4D,CACT,CGpFO,SAASQ,GAAYnE,EAAwBjH,GAClD,MAAM+J,EAAW9C,EAASQ,WAAWzH,EAAKpI,QACpCyT,EAAcpE,EAASQ,WAAWzH,EAAKpI,OAASoI,EAAKrI,QAC3D,OAAO2T,EAAAA,MAAAA,OAAavB,EAAUsB,EAChC,CCNA,MAAM,GAA+B/X,QAAQ,gDCA7C,MAAM,GAA+BA,QAAQ,sCCQ7C,IAAIiY,GAYG,SAASC,KAKd,OAJKD,IACHrK,GAAUD,IAAI,mCAGTsK,EACT,CCJA,IAAIE,GAQA,CAAC,EAGL,IAEIC,GAFAC,GAAU,EAiBP,SAASC,KACd,MAAO,CACLC,SACE5E,EACA6E,GAAc,GAKd,MAAMnS,EAAUsN,EAAStN,QACnBoS,EAAa9E,EAAS8E,WACtBC,EAAoBP,GAAexE,EAASgF,KAClD,GACED,GACAA,EAAkBrS,UAAYA,GAC9BqS,EAAkBD,aAAeA,EAGjC,OADAC,EAAkBE,MAAQ9K,KAAKC,MACxB,CACLwI,QAASmC,EAAkBG,cAC3BlF,SAAU+E,EAAkB/E,UAI5B6E,IACF7E,EAAWmF,GAAAA,aAAAA,OACTnF,EAASgF,IACThF,EAAS8E,WACT9E,EAAStN,QACTsN,EAASoF,UAAUtV,QAAQ,qBAAsB,MAIrD,MAAMoV,EAhEGlF,KAAsB,IAAAqF,EAAA,OACX,OADWA,EACnCd,WAAwB,EAAxBc,EAA0BC,kBAAkBtF,EAAS,EA+D3B1P,CAAM0P,GAE5B,IAAKkF,EACH,MAAO,CACLtC,QAAS,CACP5P,UAAMlI,EACNkY,oBAEA,GAEFhD,YAeJ,GAXAwE,GAAexE,EAASgF,KAAO,CAC7BE,gBACAxS,UACAoS,aACA9E,WACAiF,MAAO9K,KAAKC,OAET2K,GACHL,KA1EW,KA6ETA,GAAwB,CAC1B,IAAIa,EAAaC,OAAOC,UACpBC,EAAY,KAChB,IAAK,MAAMV,KAAOR,GAAgB,CAChC,MAAMO,EAAoBP,GAAeQ,GACrCD,EAAkBE,MAAQM,IAC5BG,EAAYV,EACZO,EAAaR,EAAkBE,MAEnC,CACIS,WACKlB,GAAekB,GACtBhB,KAEJ,CACA,MAAO,CAAE9B,QAASsC,EAAelF,WACnC,EACA2F,kBAAkB3F,GAChB,MAAMgF,EAAMhF,EAASgF,IACjBR,GAAeQ,YACVR,GAAeQ,GACtBN,KAEJ,EACAkB,eACiC,IAApBnB,KACToB,cAAcpB,IACdA,QAAkB3Z,EAClB0Z,GAAiB,CAAC,EAClBE,GAAU,EAEd,EAEJ,CCrIO,SAASoB,GACd/M,EACAgN,GAMA,GAJIjN,EAAeC,IAASA,EAAKoI,YAC/BpI,EAAOA,EAAKoI,WAGVnI,EAAaD,GACf,IAAK,MAAMiI,KAASjI,EAAK/L,WAAY,CACnC,GAAIgU,EAAMzH,QAAQnN,QAAU2Z,EAC1B,OAAO/E,EAGT,GAAIhI,EAAagI,EAAMG,WAAY,CACjC,MAAM6E,EAAQF,GAAa9E,EAAMG,UAAW4E,GAC5C,GAAIC,EACF,OAAOA,CAEX,CACF,CAIJ,CDKEvB,GAAkBwB,aAAY,KAC5B,MAAMC,EAAa/L,KAAKC,MAAQ+L,IAC1BC,EAAO5a,OAAOnB,KAAKma,IACzB,IAAK,MAAMQ,KAAOoB,EAAM,CACI5B,GAAeQ,GACnBC,MAAQiB,WACrB1B,GAAeQ,GACtBN,KAEJ,IACCyB,KE/CL,MAAM,GAA+B9Z,QAAQ,cCmBvCga,GAAsB,IAAIjN,IAEzBxK,eAAe0X,GACpB3F,EACA5H,GAEA,IAAKE,EAAaF,GAChB,OAGF,MAAMwN,EAAexN,EAAK3M,MAC1B,IAAI2G,EAAS6D,EAAQwM,EACrB,IACE,MAAMoD,GAAgBC,EAAAA,GAAAA,mBAAkBF,GACxCxT,EAAUyT,EAAczT,QACxB6D,EAAS4P,EAAc5P,OACvBwM,EAAgBoD,EAAcpD,aAGhC,CAFE,MAAOlZ,GACP,MACF,CAEA,MAAM,UAAE+U,SAAoBf,GAAYyC,EAAa1G,IAE/CyC,EAAmBuC,EAAUlR,SAASgF,GAE5C,IAAK2J,EAEH,YADAzC,GAAUD,IAAK,0BAAyBjH,KAI1C,MAAM2T,GAAiB3V,EAAAA,EAAAA,MAAK4P,EAAajE,EAAiB1J,MACpD2T,GAAwB5V,EAAAA,EAAAA,MAAK2V,EAAgB,gBAEnD,WAAYxV,EAAWyV,IAErB,YADA1M,GAAUD,IAAK,kCAAiC2M,KAIlD,MAAMC,QCvDDhY,eAAwBE,GAC7B,IACE,OAAOO,EAAQe,gBAAgBtB,EAAU,OAG3C,CAFE,MAAAG,GACA,MAAO,EACT,CACF,CDiD4B4X,CAASF,GAEnC,IAAIG,EAAgB,EACgC,IAAAC,EAAhDV,GAAoB3M,IAAIiN,IAC1BG,EAA8D,OAAjDC,EAAGV,GAAoB1a,IAAIgb,IAAsBI,EAAI,EAClEV,GAAoB1M,IAAIgN,EAAuBG,EAAgB,IAE/DT,GAAoB1M,IAAIgN,EAAuBG,GAGjD,MAAM,SAAE9G,EAAQ,QAAE4C,GAAY+B,KAAwBC,SACpDO,EAAAA,aAAAA,OACEwB,EACA,OACAG,EACAF,IAEF,GAGIrG,EAaR,SACEP,EACA4C,EACAhM,EACAwM,GAEA,IAAKR,EAAQ5P,KACX,OAGF,MAAMgU,EAAalB,GAAalD,EAAQ5P,KAAM,WAE9C,IAAKgU,EACH,OAIF,MAAMC,EAAiBnB,GAAakB,EAAYpQ,GAEhD,IAAKqQ,EACH,OAGF,IAAI7D,EAOF,OAAOe,GAAYnE,EAAUiH,GAPZ,CACjB,MAAMC,EAAoBpB,GAAamB,EAAgB7D,GAEvD,GAAI8D,EACF,OAAO/C,GAAYnE,EAAUkH,EAEjC,CAGF,CA7CgBC,CAAgBnH,EAAU4C,EAAShM,EAAQwM,GAEzD,OAAK7C,EAIE6G,GAAAA,IAAAA,KAAS,CACdC,OAAQ,OACRxa,KAAM8Z,EACNW,SAAW,GAAE/G,EAAMvF,MAAMuM,KAAO,MAC/B5Y,gBARH,CASF,CE3EOC,eAAe4Y,GACpBC,EACA7E,EACA5C,GACmC,IAAAqF,EACnC,MAAMqC,QAAsC,OAA9BrC,EAAMd,WAAwB,EAAxBc,EAA0BsC,QAC5C3H,EACAyH,EAAY3E,SACZF,IAGF,IAAK8E,EACH,OAGF,MAAM/W,EAASqP,EAAS+C,SAAS0E,EAAY3E,UACvC/J,EAAO6J,EAAQI,kBAAkBrS,GAEvC,OAAKoI,GAgBP,SAA8BA,GAC5B,OACEE,EAAaF,IACbD,EAAeC,EAAKO,SACU,aAA9BP,EAAKO,OAAOC,QAAQnN,QACnBwb,OAAO,sBAAsBlQ,KAAKqB,EAAK3M,QACtCwb,OAAO,UAAUlQ,KAAKqB,EAAK3M,OAEjC,CApBMyb,CAAqB9O,KACvB2O,EAAMzQ,SAAW,CACfgJ,KAAM,WACN7T,MAAQ,2CAA0C0b,GAChD/O,EAAK3M,YAKJsb,GAZEA,CAaX,CAYA,SAASI,GAAqBpa,GAC5B,MAAOsD,EAAa+W,GAAgBra,EACjCoC,QAAQ,YAAa,IACrBkY,MAAM,KACT,MAAQ,2BAA0BhX,eAAyB+W,GAC7D,CC9DA,MAAM,GAA+B1b,QAAQ,8BCchC4b,GAA8C,IAAIC,GAAAA,iBAC7D,sBAGWC,GACX,IAAID,GAAAA,iBAAiB,uBAEVE,GAIT,IAAIC,GAAAA,YAAY,gBAOPC,GAMT,IAAID,GAAAA,YAAY,iBAQPE,GAIT,IAAIF,GAAAA,YAAY,uBAEPG,GAIT,IAAIH,GAAAA,YAAY,oBAEPI,GAaT,IAAIJ,GAAAA,YAAY,+BAEPK,GACX,IAAIL,GAAAA,YAAY,cAELM,GAQT,IAAIN,GAAAA,YAAY,yBAEPO,GAIT,IAAIP,GAAAA,YAAY,yBC1FpB,MAAM,GAA+Bhc,QAAQ,iBCAvC,GAA+BA,QAAQ,MCkDtC,SAASwc,GACdC,EAA2B,CAAC,QAAS,OAAQ,SAE7C,MAAMC,EACJ,CAAC,EACH,IAAK,MAAMC,KAAYF,EACJ,SAAbE,EACFD,EAAgBC,GAtBb,CACLC,WAAUA,CAACC,EAAkBC,IACpB,IAAIzN,SAAQ,CAAC0N,EAAGlf,KACrB,MAAM8a,EAAMoC,GAAAA,IAAAA,MAAU8B,GACtBG,GAAAA,SAAYrE,EAAIsE,OAAQH,GAAU,CAAC3a,EAAK+a,KACtC,GAAI/a,EACF,OAAOtE,EAAEsE,GAEX4a,EAAEG,EAAI5a,WAAW,GACjB,KAckB,SAAbqa,GAAoC,UAAbA,IAChCD,EAAgBC,GA5Cb,CACLC,WAAUA,CAACjE,EAAawE,KAEfC,EAAAA,GAAAA,KAAI,CAAEC,IAAK1E,EAAK2E,gBAAiB,EAAGC,QAD3B,CAAE,kBAAmB,mBACiBvc,MACnDwc,GACQA,EAASC,eAEjBrb,GACQiN,QAAQqO,OACbtb,EAAMqb,eACJE,EAAAA,GAAAA,2BAA0Bvb,EAAMuP,SAChCvP,EAAME,gBAoClB,OAAQqW,IACN,MAAMgE,EAAWhE,EAAIiF,OAAO,EAAGjF,EAAIkF,QAAQ,MAErCC,EAAiBpB,EAAgBC,GACvC,OAAImB,EACKA,EAAelB,WAAWjE,GAE5BtJ,QAAQqO,OAAO,4BAA4B,CAEtD,CCvEA,MAAM,GAA+B1d,QAAQ,mBCKtCuC,eAAewb,GACpB/Y,EACAgZ,GAEA,MAAMC,QAAqBC,GAAAA,UACzBlZ,GACA,CAAC7C,EAAKgc,KACAhc,EACFyL,GAAUD,IAAI,yBAA2BxL,EAAIG,YAE7C6b,EAAOC,MACJvgB,GACCA,EAAE2C,KAAK6d,SAAS,iBAChBxgB,EAAE2C,KAAK6d,SAAS,iBAChBxgB,EAAE2C,KAAK6d,SAAS,YAChBxgB,EAAE2C,KAAK6d,SAAS,sBAGpBzQ,GAAUD,IAAI,iCAyBtB,SAAkBqQ,EAAqBM,GACrC,IAAIC,EACJ,MAAO,KACLC,aAAaD,GACbA,EAAUE,YAAW,KACnBT,GAAU,GACTM,EAAK,CAEZ,CAhCQI,CAASV,EAAU,IAAnBU,GACF,GAWN,SAAwB1Z,GACtB,MAAM/D,EAA2B,CAC/B0K,OAAQ,EAACjH,EAAAA,EAAAA,MAAKM,EAAe,kBAGZ,WAAfzE,EAAAA,EAAAA,cACFU,EAAQ0d,QAAU,WAGpB,OAAO1d,CACT,CAnBI2d,CAAe5Z,IAGjB,MAAO,KACL4I,GAAUD,IAAI,8BACdsQ,EAAaY,aAAa,CAE9B,CClCqC7e,QAAQ,4CCGtC,SAAS8e,GAAUC,GAExB,GAAIA,EAAQlB,QAAQ,iBAAmB,EAAG,MAAO,GACjD,GAAIkB,EAAQlB,QAAQ,SAAW,EAAG,MAAO,GAEzC,MAAMjW,EAAM,CAACmX,GAGb,KACEC,EAAAA,GAAAA,aAAYD,GAAS/W,SAAS+U,IAC5B,MAAMpI,EAAQnU,EAAAA,KAAUue,EAAShC,GACjC,KACOkC,EAAAA,GAAAA,UAAStK,GAAOhS,eAEVsc,EAAAA,GAAAA,UAAStK,GAAOhS,eACzBiF,EAAInH,QAAQqe,GAAUnK,IAFtB/M,EAAInH,KAAKkU,EAKX,CADA,MAAA/R,GACA,IAIJ,CADA,MAAA6C,GACA,CAEF,OAAOmC,CACT,CCzBO,IAAKsX,GAiFAC,IA3EX,SANWD,GAAAA,EAAU,UAAVA,EAAU,cAAVA,EAAU,kBAAVA,EAAU,gBAAVA,EAAU,gBAMrB,CANWA,KAAAA,GAAU,KAqFrB,SAJWC,GAAAA,EAAa,0BAAbA,EAAa,kBAAbA,EAAa,cAIxB,CAJWA,KAAAA,GAAa,KCzElB,IAAKC,GAqBAC,IAlBX,SAHWD,GAAAA,EAA8B,oCAA9BA,EAA8B,yBAGzC,CAHWA,KAAAA,GAA8B,MAyBzC,SAJWC,GAAAA,EAA6B,mCAA7BA,EAA6B,gCAA7BA,EAA6B,kBAIxC,CAJWA,KAAAA,GAA6B,KC9BlC,SAASC,GAAgBC,GAAgB,IAAAC,EAC9C,MACkB,YAAhBD,EAAOze,MACS,gBAAhBye,EAAOze,MACsB,iBAAd,OAAf0e,EAAAD,EAAOE,eAAQ,EAAfD,EAAiBE,UACQ,aAAzBH,EAAO,aAEX,CCOOhd,eAAeod,GACpBC,EACAC,GAEA,MAAM5e,GAwLiB+H,EAxLS4W,EAyLzBzgB,OAAOnB,KAAKgL,EAAOrI,YAAc,CAAC,GAAGR,QAC1C,CAAC2f,EAAYP,KACX,MAAMQ,EAAkB/W,EAAOrI,WAAW4e,GACpCE,EAAWM,EAAgBN,SAC3BO,EACsB,UAAlB,MAARP,OAAQ,EAARA,EAAoB,SAAeA,EAAgB,WAAIhhB,EACnDwhB,EACqB,iBAAlBD,EAA6BA,OAAgBvhB,EAEhDyhB,EAgBZ,SACEX,EACA7F,GACS,IAAAyG,EAGT,QAF+B,CAAC,QAELpa,SAASwZ,KAIhC,WAAY7F,GACLA,EAAyB,OAGb,OAAvByG,EAAOzG,EAASwG,UAAOC,EACzB,CA/BsBC,CAAkBb,EAAQQ,GAC1C,OAAKG,GAGLJ,EAAWrf,KAAItB,OAAAiL,OAAC,CACdtJ,KAAMye,EACNc,aAAcd,EACdU,cACGF,IAEED,GAREA,CAQQ,GAEnB,KAtBJ,IAAyB9W,EAvLvB,MAAMsX,EAAiB,IAAIzU,IAAI+T,EAAE7e,UAAY,IAEvCwf,EAAYtf,EAAQwF,KAAK8Y,IAAW,IAAAiB,EACxC,MAAMC,EAA+BlB,EAAO,YACtCmB,EACW,MAAfb,OAAe,EAAfA,EAAqC,OAAtBW,EAAGjB,EAAOc,cAAYG,EAAIjB,EAAOze,MAC5C2e,EAAWF,EAAOE,SAElBkB,EAAgBxhB,OAAAiL,OAAA,GACjBmV,EAAM,CACTqB,WAAYC,GAAgBP,EAAgBf,EAAQkB,EAAShB,GAC7DqB,QAASvB,EAAOwB,MAAQ,CAACxB,EAAOwB,OAAS,SAChBtiB,IAArBiiB,GAAkC,CAAEM,QAASN,GAC7CjB,GAAY,CAAEA,YACdF,EAAOtV,MAAQ,CAAEb,MAAOmW,EAAOtV,KAAKxD,KAAKoP,GAASA,EAAKvT,cAsIjE,SAAkBid,GAChB,OACEA,EAAOnW,OAAS,CACdA,MACGmW,EAAOnW,MAAwBa,MAC9BsV,EAAOnW,MAAmB/E,QAAUkb,EAAOnW,MAGrD,CA1IS6X,CAAS1B,IAGd,GAAIkB,IACFE,EAASO,QAAUC,GAAkBV,GAAWA,EAAQve,QAAUue,EAClEE,EAASS,aA2If,SAAyBX,GACvB,MAAMY,EAA6B,CAAC,EAC9BZ,GAAWU,GAAkBV,KAChCA,EAAQrX,OAAS,IAAIpB,SAAS6N,IACzByL,GAAuBzL,IAAWA,EAAKnC,QACzC2N,EAAaxL,EAAK9V,OAAS8V,EAAKnC,MAClC,IAGJ,OAAO2N,CACT,CArJ8BE,CAAgBd,GACpCU,GAAkBV,KAAaE,EAASvX,OAAO,CACjD,MAAMA,GAASqX,EAAQrX,OAAS,IAAI3C,KAAKoP,GACvCyL,GAAuBzL,GAAQA,EAAK9V,MAAQ8V,IAE1CzM,EAAM/E,OAAS,IACjBsc,EAASvX,MAAQA,EAErB,CAGF,OAAOuX,CAAQ,IAKXa,EAAmBjB,EAAUnC,MAChCmB,QAAoC9gB,IAAzB8gB,EAAO,gBAEjBkC,GACAC,GAEJ,OAAOnB,EAAU5e,KAAK6f,EACxB,CAWA,SAASC,GAAe1iB,EAAW4iB,GACjC,SAASC,EAAQC,GACf,OAAIA,EAAIjB,WACC,EAEiB,cAAtBiB,EAAI,cACC,EAELA,EAAI,gBACC,EAEiB,aAAtBA,EAAI,cACC,EAEF,CACT,CAEA,MAAMC,EAAQF,EAAQ7iB,GAChBgjB,EAAQH,EAAQD,GACtB,OAAIG,IAAUC,EACgB,iBAAjBhjB,EAAEkhB,YAAmD,iBAAjB0B,EAAE1B,WACxClhB,EAAEkhB,WAAa0B,EAAE1B,WAEE,iBAAjBlhB,EAAEkhB,YACH,EACyB,iBAAjB0B,EAAE1B,WACX,EAEFlhB,EAAE+B,KAAKgB,cAAc6f,EAAE7gB,MAEzBghB,EAAQC,CACjB,CAEA,SAASL,GAAqB3iB,EAAW4iB,GACvC,MAAMK,EAAwB,CAC5B,OACA,UACA,SACA,QACA,QACA,YACA,QAEIC,EAAuB,IAAIpW,IAAImW,GACrC,MAA4B,iBAAjBjjB,EAAEkhB,YAAmD,iBAAjB0B,EAAE1B,WACxClhB,EAAEkhB,WAAa0B,EAAE1B,WAGE,iBAAjBlhB,EAAEkhB,YACH,EACyB,iBAAjB0B,EAAE1B,WACX,EACElhB,EAAE6hB,WACPe,EAAEf,WACG7hB,EAAE+B,KAAKgB,cAAc6f,EAAE7gB,OAExB,EACC6gB,EAAEf,WACJ,EACEqB,EAAqB5U,IAAItO,EAAE+B,MAChCmhB,EAAqB5U,IAAIsU,EAAE7gB,MAE3BkhB,EAAsBnE,QAAQ9e,EAAE+B,MAChCkhB,EAAsBnE,QAAQ8D,EAAE7gB,OAG5B,EACCmhB,EAAqB5U,IAAIsU,EAAE7gB,MAC7B,EAEA/B,EAAE+B,KAAKgB,cAAc6f,EAAE7gB,KAElC,CAEA,SAAS+f,GACPP,EACAK,EACAF,EACAhB,GAGA,OACEa,EAAejT,IAAIsT,EAAS7f,SAKzB2f,IAAYE,EAASK,UAAYvB,GAA8B,YAAlBkB,EAASxX,IAE7D,CAYA,SAASgY,GAAkBV,GACzB,YAAyDhiB,IAAjDgiB,EAAqCve,OAC/C,CAcA,SAASof,GACPzL,GAEA,YACoDpX,IAAjDoX,EAAuC9V,YACUtB,IAAjDoX,EAAuCnC,KAE5C,CC1MqC1T,QAAQ,oCCARA,QAAQ,gDCwBtCuC,eAAe2f,GACpBld,EACA/D,GAEW,MAAPA,GAAAA,EAASkhB,uBACXhf,EAAe,eAAgB6B,GAGjC,MACE4N,WAAW,SAAElR,GAAU,UACvByE,SACQ0L,GAAY7M,GAEhBuB,QAAiBL,EACrBlB,EACAmB,EACAzE,GAGIxB,QAAoBmP,QAAQC,IAChC/I,EAASE,KAAIlE,eACEiC,EAAeyD,MAI1Bma,SACE/S,QAAQC,IACZpP,EAAYuG,KAAKsW,GAAMsF,GAAerd,EAAe+X,EAAG9b,OAE1DqhB,OAKIC,EAAqB,IAAIxV,IAC/B,IAAK,MAAMyV,KAAoBJ,EACxBI,IAKFD,EAAmBlV,IAClBoV,GAAuBD,EAAiB1hB,KAAM0hB,EAAiBrZ,QAGjEoZ,EAAmBjV,IACjBmV,GAAuBD,EAAiB1hB,KAAM0hB,EAAiBrZ,MAC/DqZ,IAKN,OAAOlb,MAAM2E,KAAKsW,EAAmB/b,SACvC,CAEAjE,eAAe8f,GACbrd,GACA,YACEP,EAAW,YACXE,EACAC,YAAarB,GAMftC,GAEA,IACE,MAAOyhB,EAAqBC,SAA8BtT,QAAQC,IAAI,CACpEhM,EAAqBC,EAAK4G,WAAa5G,EAAKqf,SAAUne,GACtDnB,EAAqBC,EAAKsf,YAActf,EAAKuf,WAAYre,KAG3D,OAAOse,GACL/d,EACAL,EACAF,EACAie,EACAC,EACA1hB,EAIJ,CAFE,MAAOpD,GACP,OAAO,IACT,CACF,CAEO0E,eAAewgB,GACpB/d,EACAge,EACAC,EACAC,EACAC,EACAliB,GAEA,MAAMmiB,EAA6C,IAAIrW,IAEjDsW,EAAsBA,CAC1BviB,EACAf,EACAoJ,EACAma,KAEA,IAAI9iB,GAAOvC,EAAAA,EAAAA,SAAQglB,GAAgBM,EAAAA,EAAAA,SAAQD,GAAavjB,EAAMiJ,QAM9D,MAJmB,WAAfzI,EAAAA,EAAAA,cACFC,EAAQ,WAAUA,EAAKiD,QAAQ,MAAO,QAGjC,CACL3C,KAAO,GAAEkiB,KAAkBliB,IAC3BqI,OACA3I,OACD,EAGG2J,EAAShL,OAAAiL,OAAA,GACV8Y,EAAmB3f,KAAK4G,UACxB+Y,EAAmB3f,KAAKqf,UAE7B,IAAK,MAAO3jB,EAAK+J,KAAW7J,OAAOsC,QAAa0I,GAAY,CAC1D,IAAKqZ,GAAOvkB,EAAK+J,EAAQ/H,EAAQwiB,cAAexiB,EAAQyiB,cACtD,SAEF,MAAMC,EAAiBN,EACrBpkB,EACA+J,EACA,WACAka,EAAmB1iB,MAGnB4iB,EAAc/V,IAAIoV,GAAuBkB,EAAe7iB,KAAM,cAIhEsiB,EAAc9V,IACZmV,GAAuBkB,EAAe7iB,KAAM,YAC5C6iB,EAEJ,CAEA,MAAMd,EAAU1jB,OAAAiL,OAAA,GACX+Y,EAAoB5f,KAAKsf,WACzBM,EAAoB5f,KAAKuf,YAE9B,IAAK,MAAO7jB,EAAK+J,KAAW7J,OAAOsC,QAAaohB,GAC9C,GAAKW,GAAOvkB,EAAK+J,EAAQ/H,EAAQwiB,cAAexiB,EAAQyiB,cAIxD,IACE,MAAMC,EAAiBN,EACrBpkB,EACA+J,EACA,YACAma,EAAoB3iB,MAOtB,GALAmjB,EAAenT,KAAOoT,GACpBZ,EACA/jB,EACA+J,GAGAoa,EAAc/V,IACZoV,GAAuBkB,EAAe7iB,KAAM,cAG9C,SAEFsiB,EAAc9V,IACZmV,GAAuBkB,EAAe7iB,KAAM,aAC5C6iB,EAGF,CADA,MAAO9lB,GACP,CAIJ,GACEslB,EAAoB5f,KAAKsgB,SACzBvc,MAAMC,QAAQ4b,EAAoB5f,KAAKsgB,SACvC,CACA,MAAMC,EAAiBX,EAAoB5f,KAAKsgB,QAC1CE,SACE1U,QAAQC,IACZwU,EACGlM,QACEoM,GACc,kBAAbA,GAA6C,oBAAbA,IAEnCvd,KAAIlE,UACH,MAAM0hB,QAAuB9b,EAC3BnD,EACAgf,GAGF,OAAKC,EAIE5B,GACLrd,QACMR,EAAeyf,GACrBhjB,GANO,IAOR,MAINqhB,OACA1K,QAAQmF,GAA2BmH,QAAQnH,KAE9C,IAAK,MAAM1c,KAAc0jB,EACnBX,EAAc/V,IAAIhN,EAAWS,OAIjCsiB,EAAc9V,IAAIjN,EAAWS,KAAMT,EAEvC,CAEA,OAAOiH,MAAM2E,KAAKmX,EAAc5c,SAClC,CAEA,SAASod,GACPZ,EACAmB,EACAC,GAEA,IAAI,IAAAC,EACF,IAAIC,EACJ,OAAQF,EAAe,WACrB,IAAK,cACHE,EAAgBnF,GAAcoF,YAC9B,MACF,IAAK,UACHD,EAAgBnF,GAAcqF,QAC9B,MACF,QACEF,EAAgBnF,GAAcsF,MAGlC,MAAO,CACL3jB,KAAMqjB,EACN9jB,WAAY2iB,EACZxW,YAAa4X,EAAe5X,aAAe,GAC3CsU,QAA+B,OAAxBuD,EAAED,EAAetD,SAAOuD,EAAI,GACnClb,KAAMmb,EAOV,CALE,MAAOzmB,GACP8R,QAAQvN,MAAMvE,GACd8R,QAAQvN,MACL,sCAAqC4gB,KAAkBmB,IAE5D,CACF,CAQA,SAASX,GACP1iB,EACA8e,EAOA8E,GAA2B,EAC3BC,GAAyB,GAEzB,QACI/E,EAAEgF,QAAUF,KACb9E,EAAEiF,UACFjF,EAAEiE,UACFjE,EAAE,kBACO,WAAT9e,GAAqB6jB,EAE1B,CAEA,SAASlC,GAAuB3hB,EAAcqI,GAC5C,MAAQ,GAAErI,KAAQqI,GACpB,CC9QA5G,eAAeuiB,GACb1hB,EACA2hB,EACA9jB,GAEA,MAAM+jB,GAA0BtgB,EAAAA,EAAAA,MAAK,QAASqgB,GAC9C,SAAUviB,GAAgBkC,EAAAA,EAAAA,MAAKtB,EAAS4hB,IAA2B,CACjE,MAAM3kB,QAWVkC,eACEa,EACA4hB,EACAD,EACA9jB,GAEA,MAAMgkB,GAAgBvgB,EAAAA,EAAAA,MAAKtB,EAAS4hB,GAC9BhC,EAAkB,cACK,eAA3B+B,EAA0C,YAAc,aAEpD9B,GAAiBve,EAAAA,EAAAA,MAAKugB,EAAe,mBAC3C,SAAUpgB,EAAWoe,GAAiB,CACpC,MAAM5iB,QAAmBiD,EACtB,GAAE2hB,qBAGL,OAAOlC,GACL3f,EACA4f,EACAC,EACA,CACEziB,KAAMyiB,EACN1f,KAAM,CAAC,GAETlD,EAAWkD,KACXtC,EAEJ,CACE,aAAaoO,QAAQC,IACnBwP,GAAUmG,GACPrN,QAAQsN,GAAsB,iBAAhBC,EAAAA,EAAAA,UAASD,KACvBze,KAAIlE,UAA0B,IAAA6iB,EAAAC,EAC7B,MAAMC,QAAmBhiB,EAAqBiiB,EAAgB,IACxDzkB,EAAOwkB,EAAW/hB,KAAKrF,IAAMonB,EAAW/hB,KAAKiiB,IAC7Crc,EACqB,OADFic,EACvBE,EAAW/hB,KAAK,WAAS6hB,EAAIjG,GAAcsF,MAC7C,MAAO,CACL3jB,KAAMkiB,EACN7Z,KAAM,YACN3I,KAAM+kB,EACN/U,KAAM,CACJ1P,OACAT,WAAY2iB,EACZ/hB,cAAe0e,GAAgB2F,EAAW/hB,MAC1CiJ,YAAwC,OAA7B6Y,EAAEC,EAAW/hB,KAAKiJ,aAAW6Y,EAAI,GAC5Clc,QAEH,IAIX,CA9D6Bsc,CACvBriB,EACA4hB,EACAD,EACA9jB,GAEF,OAAOZ,CACT,CACA,OAAOgP,QAAQpR,QAAQ,GACzB,CClDOsE,eAAemjB,GACpB1gB,EACAge,EACA2C,EACAC,GAEA,MAAMC,QAAwBviB,EAAqBsiB,GAC7CE,QAQRvjB,eAAyCyC,GACvC,MAAM,UAAE4N,SAAoBf,GAAY7M,GAExC,IAAIgG,EAAW4H,EAAUiQ,WAEzB,IAAK7X,EACH,IAKEA,EAAW4H,EAAUiQ,YAAc,CAAC,CAGtC,CAFE,MAAOhlB,GACPmN,EAAW,CAAC,CACd,CAGF,MAAM+a,EAAqB5mB,OAAOnB,KAAKgN,GAAU7K,QAC/C,CAAC6lB,EAA4B/mB,KAC3B,GAAIA,EAAI8G,SAAS,KAAM,KAAAkgB,EACrB,MAAOjD,EAAgB2C,GAAiB1mB,EAAI0c,MAAM,KAC7CqK,EAAsBhD,KACzBgD,EAAsBhD,GAAkB,CAAC,GAE3CgD,EAAsBhD,GAAgB2C,GAAyB,OAAXM,EAAGjb,QAAQ,EAARib,EAAWhnB,EACpE,KAAO,KAAAinB,EAAAC,EACL,MAAMnD,EAAiB/jB,EAClB+mB,EAAsBhD,KACzBgD,EAAsBhD,GAAkB,CAAC,GAE3C7jB,OAAOnB,KAA+B,OAA3BkoB,EAAS,OAATC,EAACnb,QAAQ,EAARmb,EAAWnD,IAAekD,EAAI,CAAC,GAAGle,SAC3C2d,IAAkB,IAAAS,EACjBJ,EAAsBhD,GAAgB2C,GAC5B,OAD0CS,EAClDpb,QAAQ,EAARob,EAAWpD,GAAgB2C,EAAc,GAGjD,CACA,OAAOK,CAAqB,GAE9B,CAAC,GAEH,OAAOD,CACT,CAlDkCM,CAA0BrhB,GACpDgG,EACJ8a,GACAA,EAAkB9C,IAClB8C,EAAkB9C,GAAgB2C,GACpC,aAAahG,GAAgBkG,EAAgBtiB,KAAMyH,EACrD,CCbOzI,eAAe+jB,GACpBC,EACAvhB,GAEA,IAAKuhB,EACH,OAAO,KAGT,MAAM,UAAE3T,SAAoBf,GAAY7M,GAElCwhB,GAAmBC,EAAAA,EAAAA,UAASzhB,EAAeuhB,GAC3C5jB,QAAoBH,EAAgB+jB,GAEpCG,EAAiBvnB,OAAOsC,QAAQmR,EAAUlR,UAChD,IAAIilB,EAA4C,KAEhD,IAAK,MAAOxW,EAAayW,KAAkBF,EAAgB,CACzD,MAAMG,EAAgBC,GAAeF,EAAcjgB,KAAM6f,GACnDO,EAAqBH,EAAcrb,YACrCkb,EAAAA,EAAAA,UAASzhB,EAAe4hB,EAAcrb,iBACtC9M,EACEuoB,EACJD,GACAD,GAAeC,EAAoBP,GAiBrC,GAfKI,EAAcnW,OAMR9N,IAAgBkkB,GAAiBG,KAGzCrkB,GACDikB,EAAcnW,MAAM2N,MAAK,EAAG3Q,UAAWA,IAAS+Y,OAHhDG,EAAeC,GANfD,EAAeM,GACb,CAAC9W,EAAayW,GACd5hB,EACAuhB,GAWAI,EACF,KAEJ,CAEA,OAAOA,CACT,CAGA,SAASM,GACPC,EACAliB,EACAuhB,GACA,IAAAY,EACA,IAAKD,EACH,OAAO,KAGT,IAAIE,EACAC,EAEJ,MAAO,CAAEvb,GAAwBob,EAC3BI,GAAkB5iB,EAAAA,EAAAA,MACtBM,EAEA8G,EAAqBnF,MAAQmF,EAAqBP,YAAc,IAE9D+b,IAAoBf,IACtBa,EAAoBF,GAGtB,MAAMK,GAAed,EAAAA,EAAAA,UAASa,EAAiBf,GAW/C,OATEgB,GACCA,EAAa/jB,WAAW,QACxBgkB,EAAAA,EAAAA,YAAWD,KAEZF,EAAsBH,IAGxBA,EAAyB,OAApBC,EAAGC,GAAiBD,EAAIE,GAEjBloB,OAAAiL,OAAA,CAAKtJ,KAAMomB,EAAM,IAAOA,EAAM,IAAO,IACnD,CAEA,SAASJ,GAAe7Z,EAAgB0H,GACtC,MAAM1M,EAAIgF,EAAOoR,SAASoJ,EAAAA,KAAOxa,EAASA,EAASwa,EAAAA,IAEnD,OADU9S,EAAM0J,SAASoJ,EAAAA,KAAO9S,EAAQA,EAAQ8S,EAAAA,KACvCjkB,WAAWyE,EACtB,CC3FO,SAASyf,GAAsB1iB,GACpC,MAAMsE,GAAY5E,EAAAA,EAAAA,MAAKijB,EAAAA,SAAU,4BAC3BC,EAAY,GAAEte,uBACpB,MAAO,CACLA,YACAie,aAAe,MAAIM,EAAAA,EAAAA,YAAUpB,EAAAA,EAAAA,UAASzhB,EAAe4iB,MACrDA,WAEJ,CCXA,MAAM,GAA+B5nB,QAAQ,iBCOtCuC,eAAeuN,GACpB9K,EACAkJ,EAAiB,CACfP,IAAIzL,GACFyN,QAAQhC,IAAIzL,EACd,IAGF,MAAM,iBAAE4Q,SAA2BjB,GAAY7M,GACzC8iB,EAAqBJ,GAAsB1iB,GAEjD,OAAO,IAAIqK,SAA4B,CAACzH,EAAKmgB,KAC3C,MAAMC,ECVH,SAA+BvV,GAMpC,IAAIuV,EAAUvV,EAAOwV,eACrB,GAAIxV,EAAOyV,eAEPF,EADgB,UAAdznB,EAAAA,EAAAA,YACQynB,EAAQvkB,QAAQ,MAAO,YAEvBukB,EAAQvkB,QAAQ,MAAO,aAGnC,GAAIgP,EAAO0V,OACTH,EAAW,OAAMA,QACZ,CACL,MAAMI,GAAiBC,EAAAA,EAAAA,sBAAqB5V,EAAO6V,KAEnDN,EAAW,IADmBO,EAAAA,EAAAA,0BAAyBH,GACpBI,QAAQR,GAC7C,CAGF,OAAOA,CACT,CDdoBS,CAAsB,CACpCH,IAAKtjB,EACLijB,eAAgB,uBAAyBH,EAAmBP,aAC5DW,eAAgBpV,EAChBqV,QAAQ,IAGVja,EAAOP,IAAK,oCAAmCqa,OAC/C,KACEU,EAAAA,GAAAA,UAASV,EAAS,CAChBM,IAAKtjB,EACL2jB,aAAa,EAIbC,MAAO,WAGThhB,OAAInJ,EAIN,CAHE,MAAOZ,GAEPkqB,EAAI,oCADiBlqB,EAAEgS,OAAO,GAAGvN,YAAczE,EAAEyE,YAEnD,IAEJ,CE6BA,IAAIumB,GACAC,GATJha,QAAQia,GAAG,sBAAuBlrB,IAChCmrB,GAAWrZ,QAAQvN,MAAMH,EAAa,sBAAsBpE,GAAG,IAGjEiR,QAAQia,GAAG,qBAAsBlrB,IAC/BmrB,GAAWrZ,QAAQvN,MAAMH,EAAY,sBAAuBpE,GAAG,IAKjE,IAAIorB,GAAoCA,OAIxC,MAAMC,GAAmB,CACvBC,oBAAqBA,CAAC5B,EAAsB6B,KAC1C,MAAM3gB,EAAO2gB,EAASC,UAAU,EAAGD,EAASE,YAAY,KAAO,GAC/D,OAAOC,GAAAA,MAAAA,YAAkBxO,GAAAA,IAAAA,MAAUtS,GAAO8e,GAAcjlB,UAAU,GAIhE0mB,IAAaQ,EAAAA,GAAAA,kBAAiBC,GAAAA,iBAAAA,KAG9BC,GAAY,IAAIC,GAAAA,cAAc7Q,EAAAA,cAIpC4Q,GAAUE,OAAOZ,IAEjBA,GAAWa,cAAatnB,UAAkB,IAAAunB,GjDzFnC,SAAsBd,GAC3B,GAAKrb,GAGH,KAAO,yBAFPA,GAAMqb,EAAWrZ,QAAQhC,IAAIoc,KAAKf,EAAWrZ,QAIjD,CiDoFEqa,CAAahB,IAEb,MAAM,cAAEhkB,GAA8C,OAA/B8kB,EAAGtf,EAAOyf,uBAAqBH,EAAI,CAAC,EAC3D,IAAI,IAAAI,EAAAC,EAAAC,EAOF,GANAvB,GACE7jB,IACuB,OADVklB,EACb1f,EAAO6f,mBAAqB,OAALF,EAAvBD,EAA0B,SAAH,EAAvBC,EAA8BxR,MAC9BnO,EAAO8f,UACPvP,GAAAA,IAAAA,MAAwB,OAAfqP,EAAC5f,EAAO+f,SAAOH,EAAI,IAAInN,QAE7B4L,GACH,KAAM,qCAGRC,GAAsBte,EAAOggB,aAE7BC,GAAiB5B,GAAcC,IAC/BG,SAA8BlL,GAC5B8K,IACAtmB,gBACQmoB,GAAY7B,UACZG,GAAW2B,iBACf7O,GAA+B8O,OAChC,GAKP,CAFE,MAAO/sB,GACP+P,GAAUD,IAAI,0BAA4B9P,EAAEyE,WAC9C,CAyCA,MAvCiC,CAC/BkoB,aAAc,CACZK,iBAAkBC,GAAAA,qBAAAA,YAClBC,mBAAoB,CAClBC,iBAAiB,EACjBC,kBAAmB,CAAC,IAAK,MAE3BC,eAAe,EACfC,qBAAsB,CACpBH,iBAAiB,EACjBI,kBAAkB,GAEpBxY,UAAW,CACTyY,eAAgB,CACdC,UAAW,CACTC,QAAS,CACP,CACEC,QAAS,CACPje,KAAM,kBACNke,QAASC,GAAAA,yBAAAA,SAKjBC,UAAW,CACTJ,QAAS,CACP,CACEC,QAAS,CACPje,KAAM,kBACNke,QAASC,GAAAA,yBAAAA,YAUZ,IAGf1C,GAAW4C,cAAarpB,UAA4B,IAAAspB,EAAA7S,EAAA8S,EAClD,IAAKjD,GACH,OAAO,IAAIkD,GAAAA,cAAc,IAAM,4CAGjC,MAAMC,EAAkBtC,GAAUpqB,IAAI2sB,EAAiBC,aAAavT,KACpE,IAAKqT,EACH,OAAO,KAGT,MAAM,QAAEzV,EAAO,SAAE5C,GAAawY,GAAgBH,GAExCI,EAKH,OALoBP,QACU,OAA9B7S,EAAMd,WAAwB,EAAxBc,EAA0BqT,WAC/B1Y,EACAsY,EAAiBxV,SACjBF,KACDsV,EAAKS,EAAAA,eAAAA,OAAsB,IAExB9V,QAAwC,OAA9BsV,EAAM5T,WAAwB,EAAxB4T,EAA0BS,mBAC9C5Y,EACA4C,IAGF,IAAKC,EACH,OAAO4V,EAGT,MAAM,UAAEjmB,SAAoB0L,GAAYgX,GAAcjb,IAEhD4e,QAAkBlW,GACtBuS,GACA1iB,EACAoQ,EACA5C,EACA6C,EACAyV,EAAiBxV,UCtMd,IAAqBgW,EAAsBC,ED0MhD,OC1M0BD,EDwMdL,EAAkBhjB,MCxMkBsjB,EDwMXF,ECvMrCllB,MAAM7H,UAAUgB,KAAKksB,MAAMF,EAAMC,GDyM1BN,CAAiB,IAG1BpD,GAAW4D,SAAQrqB,UACjB,MAAMsqB,EAAgBnD,GAAUpqB,IAAI8b,EAAY8Q,aAAavT,KAE7D,IAAKkU,EACH,OAAO,KAGT,MAAM,QAAEtW,EAAO,SAAE5C,GAAawY,GAAgBU,GAC9C,aAAa1R,GAASC,EAAa7E,EAAS5C,EAAS,IAGvDqV,GAAW8D,iBAAgBvqB,UAAkB,IAAAwqB,EAC3C,MAAMC,EAAetD,GAAUpqB,IAAIkL,EAAO0hB,aAAavT,KAEvD,IAAKqU,EACH,OAAO,KAGT,MAAM,QAAEzW,EAAO,SAAE5C,GAAawY,GAAgBa,GAExCxW,QAAwC,OAA9BuW,EAAM7U,WAAwB,EAAxB6U,EAA0BR,mBAC9C5Y,EACA4C,IAGF,OAAKC,EErNAjU,eACL+R,EACAiC,EACA5C,EACA6C,GAEA,IAAKlC,EACH,MAAO,GAGT,MAAM2Y,EAAwB,GAE9B,IAAK1W,EAAQ5P,KACX,MAAO,GAGT,MAAMuO,EAAcR,GAAgB6B,EAAQ5P,MACtCumB,GAAkBxoB,EAAAA,EAAAA,MAAK4P,EAAaY,GAE1C,IAAK,MAAM,OAAElM,EAAM,KAAE0D,KAAU8J,EAAS,CACtC,IAAI2W,EACJ,GAAIpkB,EAAkBC,GACpBmkB,EAAWnkB,EAAOJ,QACb,GAAIwE,EAAyBV,GAAO,KAAA0gB,EACzCD,EAAyC,OAAjCC,EAAGpgB,EAAyBN,SAAK,EAA9B0gB,EAAgC5f,cAC7C,CAEA,IAAK2f,EACH,SAGF,GAAiB,cAAbA,EACF,SAGF,MAAMjZ,EAAQ4D,GAAYnE,EAAUjH,GAEpC,OAAQygB,GACN,IAAK,OAAQ,CACX,IAAKvgB,EAAaF,GAChB,SAGF,MAAMkb,GAAWljB,EAAAA,EAAAA,MAAK4P,EAAa5H,EAAK3M,OACxC,WAAY8E,EAAW+iB,IACrB,SAGElb,EAAK3M,QAAUmV,EACjB+X,EAAMxsB,KAAK,CACTyT,QACA3J,OAAQ2iB,IAGVD,EAAMxsB,KAAK4sB,EAAAA,aAAAA,OAAoBnZ,EAAO0T,IAExC,KACF,CACA,IAAK,gBAAiB,CACpB,MAAM0F,QAAarT,GAAW3F,EAAa5H,GACvC4gB,GACFL,EAAMxsB,KAAK4sB,EAAAA,aAAAA,OAAoBnZ,EAAOoZ,IAExC,KACF,EAGJ,CAEA,OAAOL,CACT,CFmJSM,CAAiB1E,GAActS,EAAS5C,EAAU6C,QAJzD,CAIiE,IAGnE,MAAMgX,GAAqBlV,KAwJ3B/V,eAAemoB,GAAYpW,SACnBzC,GAAYyC,EAAa1G,IAAW,SACpC6c,GAAiBnW,EAAawU,GACtC,CAEAvmB,eAAekoB,GACbnW,EACAkW,GAEA,IAAKlW,EAEH,YADA1G,GAAUD,IAAI,8BAIhB,MAAM,UAAEiF,EAAS,UAAEzM,SAAoB0L,GAAYyC,EAAa1G,IAC1D1N,QGjZDqC,eACLyC,EACA/D,EAA+B,CAC7BwiB,eAAe,EACftB,uBAAuB,IAGzB,aACQD,GAAgBld,EAAe,CACnCmd,sBAAuBlhB,EAAQkhB,sBAC/BsB,cAAexiB,EAAQwiB,iBAEzB7L,QAAQvX,GAAmC,aAApBA,EAAW8I,MACtC,CHoY4BskB,CAAanZ,GACjCoZ,EItZD,SAAgCxtB,GACrC,MAAO0iB,EAAUzY,GAAalK,EAAiCC,GACzD0K,EAIR,SACEgY,EACAzY,GAEA,MAAO,CACLwjB,MAAO,gCACPzvB,GAAI,iBACJiL,KAAM,SACNxI,WAAY,CACV0F,QAAS,CACP8C,KAAM,SACNc,KAAM,CAAC,EAAG,KAGdQ,MAAO,CACL,CACE/J,GAAI,CACFC,WAAY,CAAE0F,QAAS,CAAExF,MAAO,IAChCE,SAAU,CAAC,YAEbC,KAAM,CACJL,WAAY,CACVe,SAAU,CACRyH,KAAM,SACN/H,qBAAsB,CACpB+H,KAAM,SACNxI,WAAY,CACVitB,UAAW,CACTphB,YACE,qFACFpL,qBAAsB,CACpB+H,KAAM,SACNxI,WAAY,CACVC,QAAS,CACP4L,YACE,+DACFrD,KAAM,UAERlI,QAAS,CACPkI,KAAM,UAERhI,eAAgB,CACdqL,YACE,yEACFpL,qBAAsB,CACpB+H,KAAM,YAIZsB,MAAOmY,UASvB,CACEliB,GAAI,CACFC,WAAY,CAAE0F,QAAS,CAAExF,MAAO,IAChCE,SAAU,CAAC,YAEbC,KAAM,CACJL,WAAY,CACVe,SAAU,CACRyH,KAAM,SACN/H,qBAAsB,CACpB2I,MAAO,CACL,CACEZ,KAAM,UAER,CACEA,KAAM,SACNxI,WAAY,CACVuJ,QAAS,CACPsC,YACE,qFACFpL,qBAAsB,CACpB+H,KAAM,SACNxI,WAAY,CACVU,SAAU,CACRmL,YACE,4DACFrD,KAAM,UAERlI,QAAS,CACPkI,KAAM,UAERhI,eAAgB,CACdqL,YACE,yEACFpL,qBAAsB,CACpB+H,KAAM,YAIZsB,MAAON,aAajC,CAlHmBqB,CAAiBoX,EAAUzY,GAC5C,OAAOS,CACT,CJkZ0BijB,CAAuB3tB,GACzC4tB,EAAgBpjB,EACpBxK,EACA0S,EAAUjI,eACVxE,GAEI4nB,EAAgBtiB,EAAqBtF,GAErC6nB,EAAWpiB,EAAgB1L,EAAa0S,EAAUlR,SAAUyE,G9BxZ7D,IACLqE,EACAyjB,EADAzjB,E8B0ZE,CACE0jB,qBAAsB1R,GAAwB,CAAC,SAC/C0M,oBACAiF,cAAe,GACfC,mBAAoB5D,G9B7ZxByD,E8B+ZE,CACEzX,QAAS,CACP,CACEmC,IAAK,yBACL0V,UAAW,CAAC,qBACZrlB,OAAQ0kB,GAEV,CACE/U,IAAK,uBACL0V,UAAW,CAAC,mBACZrlB,OAAQ8kB,GAEV,CACEnV,IAAK,uBACL0V,UAAW,CAAC,mBACZrlB,OAAQ+kB,GAEV,CACEpV,IAAK,kBACL0V,UAAW,CAAC,cACZrlB,OAAQglB,K9BjbhB/V,IAAkBqW,EAAAA,EAAAA,oBAAmB9jB,GACrCyN,GAAgBsW,UAAUN,E8Bqb5B,CAEA,SAAS9B,GAAgBxY,GACvB,OAAO6Z,GAAmBjV,SAAS5E,EACrC,CApNA+V,GAAU8E,YAAY3wB,IACpB2vB,GAAmBlU,kBAAkBzb,EAAE8V,SAAS,IAGlDqV,GAAWyF,YAAW,KACpBxF,KACAuE,GAAmBjU,SAAS,IAG9ByP,GAAW0F,UAAU3S,IAAoBxZ,OAASuP,WAC3C+W,GAIEhX,GAAYgX,GAAcjb,GAAWkE,GAHnC,IAAIia,GAAAA,cAAc,IAAM,8CAMnC/C,GAAW0F,UACTzS,IACA1Z,SACOsmB,GP5PFtmB,eACLyC,EACA/D,EAAsC,CACpCwiB,eAAe,EACfC,cAAc,IAGhB,MAAMtgB,EAAU4B,EAMhB,IAAI2d,SALsBT,GAAgBld,EAAe,CACvDmd,uBAAuB,EACvBsB,cAAexiB,EAAQwiB,cACvBC,aAAcziB,EAAQyiB,gBAEe9L,QACpCvX,GAAmC,cAApBA,EAAW8I,OAQ7B,OALAwZ,EAAuB,IAClBA,WACOmC,GAAgC1hB,EAAS,aAAcnC,YACvD6jB,GAAgC1hB,EAAS,aAAcnC,IAE5D0hB,EAAqB/K,QACzBvX,KAA+CA,EAAWmQ,MAE/D,CO0OWme,CAAc9F,GAAchb,EAAK5M,SAN/B,IAAI8qB,GAAAA,cACT,IACA,8CAQR/C,GAAW0F,UACTxS,IACA3Z,SACOsmB,GAOEnD,GACLmD,GACAhb,EAAK5M,QAAQZ,WACbwN,EAAK5M,QAAQH,KACb+M,EAAK5M,QAAQT,MAVN,IAAIurB,GAAAA,cACT,IACA,8CAaR/C,GAAW0F,UACTvS,IACA5Z,SACOsmB,GAMEvC,GAAiBzY,EAAK+gB,YAAa/F,IALjC,IAAIkD,GAAAA,cACT,IACA,8CAOR/C,GAAW0F,UACTtS,IACA7Z,SACOsmB,GK/SFtmB,eACLssB,EACAruB,EACAwE,GASA,IAAA8pB,EACA,IAAKtuB,EACH,OAEF,MAAMkG,QAAgB4f,GAAiB9lB,EAAMwE,GACvCmL,EAAezJ,GAAWA,EAAQ5F,WAASrC,EAEjD,IAAIswB,EAAevuB,EAChBiD,QAAQuB,EAAe,IACvBvB,QAAQ,MAAO,KACfA,QAAQ,MAAO,IAElB,MAAM,gBAAEuP,SAA0BnB,GAAY7M,GACxCiO,EAAUD,EAAgBC,QAC1BC,EAAUF,EAAgBE,QAkBhC,OAhBED,IACqB,iBAAX,MAAT4b,OAAS,EAATA,EAAW/tB,OACU,SAAX,MAAT+tB,OAAS,EAATA,EAAW/tB,OACXiuB,EAAavrB,WAAWyP,MAE1B8b,EAAeA,EAAatrB,QAAQwP,EAAS,IAAIxP,QAAQ,MAAO,KAGhEyP,IACqB,aAAX,MAAT2b,OAAS,EAATA,EAAW/tB,OACU,SAAX,MAAT+tB,OAAS,EAATA,EAAW/tB,OACXiuB,EAAavrB,WAAW0P,MAE1B6b,EAAeA,EAAatrB,QAAQyP,EAAS,IAAIzP,QAAQ,MAAO,KAGlEtE,OAAAiL,OAAA,CACE1D,QAASyJ,EACTA,cACA3P,KAAMuuB,KACA5e,GAAwB,MAAT0e,GAAkB,OAATC,EAATD,EAAW5tB,UAAX6tB,EAAoB1Q,KAAKkB,MAAqB,CACjEhW,UAAWylB,GAGjB,CLiQWC,CAA4BnhB,EAAKghB,UAAWhhB,EAAKrN,KAAMqoB,IALrD,IAAIkD,GAAAA,cACT,IACA,8CAOR/C,GAAW0F,UAAUrS,IAAkB9Z,SAChCsmB,GAGEvX,GAAauX,IAFX,IAAIkD,GAAAA,cAAc,IAAM,8CAKnC/C,GAAW0F,UAAUpS,IAA6B/Z,SAC3CsmB,GAGEnB,GAAsBmB,IAFpB,IAAIkD,GAAAA,cAAc,IAAM,8CAKnC/C,GAAW0F,UAAUnS,IAA6Bha,UAChD,IAAKsmB,GACH,OAAO,IAAIkD,GAAAA,cAAc,IAAM,4CAEjC,UACQjc,GAAmB+Y,GAAcjb,GAGzC,CAFE,MAAO/P,GACP,OAAOA,CACT,KAGFmrB,GAAWiG,eAAenT,IAAgCvZ,UACxD,IAAKsmB,GACH,OAAO,IAAIkD,GAAAA,cAAc,KAAM,kDAG3BrB,GAAY7B,GAAa,IAGjCG,GAAWiG,eACT,4BACA1sB,UACE,GAAK2sB,EAAaze,MAAM2N,MAAM8G,GAAMA,EAAEvM,IAAI0F,SAAS,kBAInD,OAAKwK,cAOC6B,GAAY7B,KANT,IAAIkD,GAAAA,cACT,KACA,2CAI2B,IAInC/C,GAAWiG,eACT,4BACA1sB,UACE,GAAK4sB,EAAa1e,MAAM2N,MAAM8G,GAAMA,EAAEvM,IAAI0F,SAAS,kBAInD,OAAKwK,cAOC6B,GAAY7B,KANT,IAAIkD,GAAAA,cACT,KACA,2CAI2B,IAInC/C,GAAWiG,eAAerT,IAAmBrZ,UAC3CsmB,GAAe7jB,QACT0lB,GAAY7B,GAAa,IAmEjCG,GAAWY,Q","sources":["webpack://nxls/../../libs/language-server/workspace/src/lib/ sync","webpack://nxls/../../libs/shared/npm/src/lib/ sync","webpack://nxls/webpack/bootstrap","webpack://nxls/webpack/runtime/compat get default export","webpack://nxls/webpack/runtime/define property getters","webpack://nxls/webpack/runtime/hasOwnProperty shorthand","webpack://nxls/webpack/runtime/make namespace object","webpack://nxls/external commonjs \"core-js/modules/es.regexp.to-string.js\"","webpack://nxls/external commonjs \"core-js/modules/es.promise.js\"","webpack://nxls/external commonjs \"core-js/modules/es.string.ends-with.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.iterator.js\"","webpack://nxls/external commonjs \"core-js/modules/web.dom-collections.iterator.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.includes.js\"","webpack://nxls/external commonjs \"core-js/modules/es.string.includes.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.reduce.js\"","webpack://nxls/external node-commonjs \"os\"","webpack://nxls/../../libs/shared/json-schema/src/lib/create-builders-and-executors-schema.ts","webpack://nxls/external commonjs \"core-js/modules/es.object.assign.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.sort.js\"","webpack://nxls/external commonjs \"core-js/modules/es.object.from-entries.js\"","webpack://nxls/external commonjs \"core-js/modules/es.regexp.exec.js\"","webpack://nxls/external commonjs \"core-js/modules/es.string.replace.js\"","webpack://nxls/external commonjs \"core-js/modules/es.regexp.constructor.js\"","webpack://nxls/../../libs/shared/utils/src/lib/utils.ts","webpack://nxls/external node-commonjs \"path\"","webpack://nxls/external commonjs \"core-js/modules/es.string.starts-with.js\"","webpack://nxls/external node-commonjs \"fs/promises\"","webpack://nxls/../../libs/shared/file-system/src/lib/directory-exists.ts","webpack://nxls/external commonjs \"@yarnpkg/fslib\"","webpack://nxls/external commonjs \"@yarnpkg/libzip\"","webpack://nxls/external commonjs \"jsonc-parser\"","webpack://nxls/../../libs/shared/file-system/src/lib/cache-json.ts","webpack://nxls/../../libs/shared/npm/src/lib/package-details.ts","webpack://nxls/../../libs/shared/file-system/src/lib/file-exists.ts","webpack://nxls/../../libs/shared/npm/src/lib/pnp-dependencies.ts","webpack://nxls/../../libs/shared/npm/src/lib/workspace-dependencies.ts","webpack://nxls/../../libs/shared/npm/src/lib/npm-dependencies.ts","webpack://nxls/../../libs/shared/npm/src/lib/find-nx-package-path.ts","webpack://nxls/external commonjs \"semver\"","webpack://nxls/external commonjs \"nx/src/devkit-exports\"","webpack://nxls/external commonjs \"vscode-json-languageservice\"","webpack://nxls/../../libs/shared/json-schema/src/lib/completion-type.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/common-json-schema.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/project-json-schema.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/package-json-schema.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/nx-json-schema.ts","webpack://nxls/../../libs/language-server/utils/src/lib/node-types.ts","webpack://nxls/../../libs/language-server/utils/src/lib/default-completion.ts","webpack://nxls/external commonjs \"rxjs\"","webpack://nxls/external commonjs \"core-js/modules/es.string.match.js\"","webpack://nxls/../../libs/language-server/utils/src/lib/lsp-log.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-nx-workspace-package.ts","webpack://nxls/external node-commonjs \"perf_hooks\"","webpack://nxls/../../libs/language-server/workspace/src/lib/get-nx-workspace-config.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-nx-version.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/workspace.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/create-completion-path-item.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/input-name-completion.ts","webpack://nxls/../../libs/language-server/utils/src/lib/find-project-root.ts","webpack://nxls/external commonjs \"fast-glob\"","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/path-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/tags-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/targets-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/get-completion-items.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/project-target-completion.ts","webpack://nxls/../../libs/language-server/capabilities/code-completion/src/lib/project-completion.ts","webpack://nxls/../../libs/language-server/capabilities/document-links/src/lib/create-range.ts","webpack://nxls/external commonjs \"@nx/devkit/src/executors/parse-target-string\"","webpack://nxls/external commonjs \"vscode-languageserver-textdocument\"","webpack://nxls/../../libs/language-server/utils/src/lib/json-language-service.ts","webpack://nxls/../../libs/language-server/utils/src/lib/language-model-cache.ts","webpack://nxls/../../libs/language-server/utils/src/lib/find-property.ts","webpack://nxls/external commonjs \"vscode-uri\"","webpack://nxls/../../libs/language-server/capabilities/document-links/src/lib/target-link.ts","webpack://nxls/../../libs/shared/file-system/src/lib/read-file.ts","webpack://nxls/../../libs/language-server/capabilities/hover/src/lib/get-hover.ts","webpack://nxls/external commonjs \"vscode-languageserver/node\"","webpack://nxls/../../libs/language-server/types/src/index.ts","webpack://nxls/external commonjs \"request-light\"","webpack://nxls/external node-commonjs \"fs\"","webpack://nxls/../../libs/language-server/utils/src/lib/runtime.ts","webpack://nxls/external commonjs \"@parcel/watcher\"","webpack://nxls/../../libs/language-server/watcher/src/lib/watcher.ts","webpack://nxls/external commonjs \"core-js/modules/es.symbol.description.js\"","webpack://nxls/../../libs/shared/file-system/src/lib/list-files.ts","webpack://nxls/../../libs/shared/schema/src/schema.ts","webpack://nxls/../../libs/shared/schema/src/task-execution-messages.ts","webpack://nxls/../../libs/shared/schema/src/is-project-option.ts","webpack://nxls/../../libs/shared/schema/src/normalize-schema.ts","webpack://nxls/external commonjs \"core-js/modules/es.array.flat.js\"","webpack://nxls/external commonjs \"core-js/modules/es.array.unscopables.flat.js\"","webpack://nxls/../../libs/language-server/workspace/src/lib/read-collections.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-generators.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-generator-options.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-project-by-path.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-project-graph-output.ts","webpack://nxls/external node-commonjs \"child_process\"","webpack://nxls/../../libs/language-server/workspace/src/lib/create-project-graph.ts","webpack://nxls/../../libs/shared/utils/src/lib/get-nx-execution-command.ts","webpack://nxls/./src/main.ts","webpack://nxls/../../libs/language-server/utils/src/lib/merge-arrays.ts","webpack://nxls/../../libs/language-server/capabilities/document-links/src/lib/get-document-links.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-executors.ts","webpack://nxls/../../libs/shared/json-schema/src/lib/workspace-json-schema.ts","webpack://nxls/../../libs/language-server/workspace/src/lib/get-generator-context-from-path.ts"],"sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 250;\nmodule.exports = webpackEmptyContext;","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 354;\nmodule.exports = webpackEmptyContext;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.regexp.to-string.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.promise.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.ends-with.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.iterator.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/web.dom-collections.iterator.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.includes.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.includes.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.reduce.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"os\");","import { CollectionInfo } from '@nx-console/shared/schema';\nimport { platform } from 'os';\nimport { JSONSchema } from 'vscode-json-languageservice';\n\ntype BuildersSchema = JSONSchema;\ntype ExecutorsSchema = JSONSchema;\n\n/**\n * Builds the schema for builders and executors.\n *\n * @param collections\n * @returns [BuildersSchema[], ExecutorsSchema[]]\n */\nexport function createBuildersAndExecutorsSchema(\n  collections: CollectionInfo[]\n): [BuildersSchema[], ExecutorsSchema[]] {\n  return collections.reduce<[BuildersSchema[], ExecutorsSchema[]]>(\n    (acc, collection) => {\n      const schemaRef =\n        platform() === 'win32' ? collection.path : `file://${collection.path}`;\n\n      acc[0].push({\n        if: {\n          properties: { builder: { const: collection.name } },\n          required: ['builder'],\n        },\n        then: {\n          properties: {\n            options: {\n              $ref: schemaRef,\n            },\n            configurations: {\n              additionalProperties: {\n                $ref: schemaRef,\n                required: [],\n              },\n            },\n          },\n        },\n      });\n      acc[1].push({\n        if: {\n          properties: { executor: { const: collection.name } },\n          required: ['executor'],\n        },\n        then: {\n          properties: {\n            options: {\n              $ref: schemaRef,\n            },\n            configurations: {\n              additionalProperties: {\n                $ref: schemaRef,\n                required: [],\n              },\n            },\n          },\n        },\n      });\n      return acc;\n    },\n    [[], []]\n  );\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.object.assign.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.sort.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.object.from-entries.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.regexp.exec.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.replace.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.regexp.constructor.js\");","import { NxWorkspaceConfiguration } from '@nx-console/shared/types';\n\nexport function getPrimitiveValue(value: any): string | undefined {\n  if (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  ) {\n    return value.toString();\n  } else {\n    return undefined;\n  }\n}\n\nexport function sortWorkspaceProjects(\n  w: NxWorkspaceConfiguration\n): NxWorkspaceConfiguration {\n  const sortedProjects = Object.entries(w.projects || {}).sort(\n    (projectA, projectB) => projectA[0].localeCompare(projectB[0])\n  );\n  w.projects = Object.fromEntries(sortedProjects);\n  return w;\n}\n\nexport function hasKey<T extends object>(\n  obj: T,\n  key: PropertyKey\n): key is keyof T {\n  return key in obj;\n}\n\nexport function formatError(message: string, err: any): string {\n  if (err instanceof Error) {\n    const error = <Error>err;\n    return `${message}: ${error.message}\\n${error.stack}`;\n  } else if (typeof err === 'string') {\n    return `${message}: ${err}`;\n  } else if (err) {\n    return `${message}: ${err.toString()}`;\n  }\n  return message;\n}\n\nexport function matchWithWildcards(\n  text: string,\n  expression: string,\n  strict = true\n) {\n  const escapeRegex = (str: string) =>\n    str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1');\n  return new RegExp(\n    `${strict ? '^' : ''}${expression.split('*').map(escapeRegex).join('.*')}$`\n  ).test(text);\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.starts-with.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs/promises\");","import { stat } from 'fs/promises';\n\nexport async function directoryExists(filePath: string): Promise<boolean> {\n  try {\n    return (await stat(filePath)).isDirectory();\n  } catch {\n    return false;\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@yarnpkg/fslib\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@yarnpkg/libzip\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"jsonc-parser\");","import * as path from 'path';\nimport { PosixFS, ZipOpenFS } from '@yarnpkg/fslib';\nimport { getLibzipSync as libzip } from '@yarnpkg/libzip';\n\nimport { parse as parseJson, ParseError } from 'jsonc-parser';\n\nconst zipOpenFs = new ZipOpenFS({ libzip });\nexport const crossFs = new PosixFS(zipOpenFs);\nexport const files: { [path: string]: string[] } = {};\nexport const fileContents: { [path: string]: any } = {};\n\nexport async function readAndParseJson(filePath: string) {\n  const content = await crossFs.readFilePromise(filePath, 'utf8');\n  try {\n    return JSON.parse(content);\n  } catch {\n    const errors: ParseError[] = [];\n    const result = parseJson(content, errors);\n\n    if (errors.length > 0) {\n      for (const { error, offset } of errors) {\n        // TODO(cammisuli): output this generically\n        // getOutputChannel().appendLine(\n        //   `${printParseErrorCode(\n        //     error\n        //   )} in JSON at position ${offset} in ${filePath}`\n        // );\n      }\n    }\n\n    return result;\n  }\n}\n\nexport function clearJsonCache(filePath: string, basedir = '') {\n  const fullFilePath = path.join(basedir, filePath);\n  return delete fileContents[fullFilePath];\n}\n\nexport async function readAndCacheJsonFile(\n  filePath: string | undefined,\n  basedir = ''\n): Promise<{ path: string; json: any }> {\n  if (!filePath) {\n    return {\n      path: '',\n      json: {},\n    };\n  }\n  let fullFilePath = path.join(basedir, filePath);\n  if (fullFilePath.startsWith('file:\\\\')) {\n    fullFilePath = fullFilePath.replace('file:\\\\', '');\n  }\n  try {\n    const stats = await crossFs.statPromise(fullFilePath);\n    if (fileContents[fullFilePath] || stats.isFile()) {\n      fileContents[fullFilePath] ||= await readAndParseJson(fullFilePath);\n      return {\n        path: fullFilePath,\n        json: fileContents[fullFilePath],\n      };\n    }\n  } catch (e) {\n    // TODO(cammisuli): output this generically\n    // getOutputChannel().appendLine(`${fullFilePath} does not exist`);\n  }\n\n  return {\n    path: fullFilePath,\n    json: {},\n  };\n}\n\n/**\n * Caches already created json contents to a file path\n */\nexport function cacheJson(filePath: string, basedir = '', content?: any) {\n  const fullFilePath = path.join(basedir, filePath);\n  if (fileContents[fullFilePath]) {\n    return {\n      json: fileContents[fullFilePath],\n      path: fullFilePath,\n    };\n  }\n\n  if (content) {\n    fileContents[fullFilePath] = content;\n  }\n  return {\n    json: content,\n    path: fullFilePath,\n  };\n}\n","import { readAndCacheJsonFile } from '@nx-console/shared/file-system';\nimport { join } from 'path';\n\nexport async function packageDetails(packagePath: string) {\n  const { json } = await readAndCacheJsonFile(\n    join(packagePath, 'package.json')\n  );\n  return {\n    packagePath,\n    packageName: json.name,\n    packageJson: json,\n  };\n}\n","import { stat } from 'fs/promises';\n\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    return (await stat(filePath)).isFile();\n  } catch {\n    return false;\n  }\n}\n","import type { PnpApi } from '@yarnpkg/pnp';\nimport { join } from 'path';\nimport { fileExists } from '@nx-console/shared/file-system';\n\nlet PNP_API: PnpApi;\n\nasync function getPnpFile(workspacePath: string) {\n  const extensions = ['.cjs', '.js'];\n  for (const ext of extensions) {\n    try {\n      const fileName = `.pnp${ext}`;\n      const pnpFile = join(workspacePath, fileName);\n      if (await fileExists(pnpFile)) {\n        return pnpFile;\n      }\n    } catch {\n      return;\n    }\n  }\n}\n\nasync function pnpApi(workspacePath: string) {\n  const pnpFile = await getPnpFile(workspacePath);\n  if (!pnpFile) {\n    return;\n  }\n\n  if (!PNP_API) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const pnp = require(pnpFile);\n    pnp.setup();\n    PNP_API = pnp;\n  }\n\n  return PNP_API;\n}\n\nexport async function isWorkspaceInPnp(workspacePath: string) {\n  try {\n    const file = await getPnpFile(workspacePath);\n    return !!file;\n  } catch {\n    return false;\n  }\n}\n\nexport async function pnpDependencies(workspacePath: string) {\n  const pnp = await pnpApi(workspacePath);\n\n  if (!pnp) {\n    return [];\n  }\n\n  pnp.resolveRequest;\n\n  const dependencies = [];\n  for (const locator of pnp.getDependencyTreeRoots()) {\n    const pkg = pnp.getPackageInformation(locator);\n    if (!pkg?.packageDependencies) {\n      continue;\n    }\n    for (const [name, reference] of pkg?.packageDependencies ?? {}) {\n      // Unmet peer dependencies\n      if (reference === null) continue;\n      if (!Array.isArray(reference) && reference.startsWith('workspace:'))\n        continue;\n\n      const path = await pnpDependencyPath(workspacePath, name);\n      if (path) {\n        dependencies.push(path);\n      }\n    }\n  }\n  return dependencies;\n}\n\nexport async function pnpDependencyPath(\n  workspacePath: string,\n  dependencyName: string\n) {\n  try {\n    const pnp = await pnpApi(workspacePath);\n\n    if (!pnp) {\n      return;\n    }\n\n    let path: string =\n      pnp.resolveToUnqualified(dependencyName, workspacePath + '/') ?? '';\n    if (path.includes('__virtual__')) {\n      path = pnp.resolveVirtual?.(path) ?? '';\n    }\n\n    return path;\n  } catch {\n    return;\n  }\n}\n","import { directoryExists } from '@nx-console/shared/file-system';\nimport { WorkspaceProjects } from '@nx-console/shared/schema';\nimport { NxVersion } from '@nx-console/shared/types';\nimport { stat } from 'fs/promises';\nimport { join } from 'path';\nimport { npmDependencies } from './npm-dependencies';\nimport { packageDetails } from './package-details';\nimport {\n  isWorkspaceInPnp,\n  pnpDependencies,\n  pnpDependencyPath,\n} from './pnp-dependencies';\n\n/**\n * Get dependencies for the current workspace.\n * This is needed to continue to support Angular CLI projects.\n *\n */\n\nexport async function workspaceDependencies(\n  workspacePath: string,\n  nxVersion: NxVersion,\n  projects?: WorkspaceProjects\n): Promise<string[]> {\n  const dependencies: string[] = [];\n\n  dependencies.push(\n    ...(await localDependencies(workspacePath, nxVersion, projects))\n  );\n\n  if (await isWorkspaceInPnp(workspacePath)) {\n    dependencies.push(...(await pnpDependencies(workspacePath)));\n  }\n\n  dependencies.push(...(await npmDependencies(workspacePath)));\n\n  return dependencies;\n}\n\nexport async function workspaceDependencyPath(\n  workspacePath: string,\n  workspaceDependencyName: string\n) {\n  if (workspaceDependencyName.startsWith('.')) {\n    return join(workspacePath, workspaceDependencyName);\n  }\n\n  if (await isWorkspaceInPnp(workspacePath)) {\n    return pnpDependencyPath(workspacePath, workspaceDependencyName);\n  }\n\n  const nodeModulesPath = join(\n    workspacePath,\n    'node_modules',\n    workspaceDependencyName\n  );\n  const encapsulatedPath = join(\n    workspacePath,\n    '.nx',\n    'installation',\n    'node_modules',\n    workspaceDependencyName\n  );\n\n  try {\n    if (await directoryExists(nodeModulesPath)) {\n      return nodeModulesPath;\n    } else if (await directoryExists(encapsulatedPath)) {\n      return encapsulatedPath;\n    } else {\n      return undefined;\n    }\n  } catch {\n    return;\n  }\n}\n\nexport async function localDependencyPath(\n  workspacePath: string,\n  workspaceDependencyName: string,\n  projects: WorkspaceProjects\n): Promise<string | undefined> {\n  for (const project of Object.values(projects)) {\n    const projectPath = join(workspacePath, project.root);\n    const pkgDetails = await packageDetails(projectPath);\n    if (pkgDetails.packageName === workspaceDependencyName) {\n      return pkgDetails.packagePath;\n    }\n  }\n}\n\nasync function localDependencies(\n  workspacePath: string,\n  version: NxVersion,\n  projects?: WorkspaceProjects\n): Promise<string[]> {\n  if (!projects) {\n    return [];\n  }\n\n  // Local plugins do not work with nxVersion less than 13\n  if (version.major < 13) {\n    return [];\n  }\n\n  const packages = Object.values(projects).map(\n    (project) => `${workspacePath}/${project.root}/package.json`\n  );\n\n  const existingPackages: string[] = [];\n\n  for (const pkg of packages) {\n    try {\n      const fileStat = await stat(pkg);\n      if (fileStat.isFile()) {\n        existingPackages.push(pkg.replace('/package.json', ''));\n      }\n    } catch {\n      // noop\n    }\n  }\n\n  return existingPackages;\n}\n","import { stat, readdir } from 'fs/promises';\nimport { join } from 'path';\n\n/**\n * Get a flat list of all node_modules folders in the workspace.\n * This is needed to continue to support Angular CLI projects.\n *\n * @param workspacePath\n * @returns\n */\nexport async function npmDependencies(workspacePath: string) {\n  const nodeModules = join(workspacePath, 'node_modules');\n  const nodeModulesEncapsulated = join(\n    workspacePath,\n    '.nx',\n    'installation',\n    'node_modules'\n  );\n\n  let nodeModulesDir = nodeModules;\n\n  const res: string[] = [];\n  try {\n    if (!(await stat(nodeModules)).isDirectory()) {\n      return res;\n    }\n  } catch {\n    try {\n      if (!(await stat(nodeModulesEncapsulated)).isDirectory()) {\n        return res;\n      } else {\n        nodeModulesDir = nodeModulesEncapsulated;\n      }\n    } catch {\n      return res;\n    }\n  }\n\n  const dirContents = await readdir(nodeModulesDir);\n\n  for (const npmPackageOrScope of dirContents) {\n    if (npmPackageOrScope.startsWith('.')) {\n      continue;\n    }\n\n    const packageStats = await stat(join(nodeModulesDir, npmPackageOrScope));\n    if (!packageStats.isDirectory()) {\n      continue;\n    }\n\n    if (npmPackageOrScope.startsWith('@')) {\n      (await readdir(join(nodeModulesDir, npmPackageOrScope))).forEach((p) => {\n        res.push(`${nodeModulesDir}/${npmPackageOrScope}/${p}`);\n      });\n    } else {\n      res.push(`${nodeModulesDir}/${npmPackageOrScope}`);\n    }\n  }\n\n  return res;\n}\n","import { join } from 'path';\nimport { fileExists } from '@nx-console/shared/file-system';\nimport { workspaceDependencyPath } from './workspace-dependencies';\n\n/**\n * Finds the local Nx package in the workspace.\n *\n * It will try to look for the `nx` package, with the specific file. If it does not exist, it will try to look for the `@nrwl/workspace` package, with the specific file\n * @param workspacePath\n * @returns\n */\nexport async function findNxPackagePath(\n  workspacePath: string,\n  filePath: string\n): Promise<string | undefined> {\n  const buildPath = (base: string) => join(base, filePath);\n\n  const nxWorkspaceDepPath = await workspaceDependencyPath(workspacePath, 'nx');\n  if (nxWorkspaceDepPath) {\n    const path = buildPath(nxWorkspaceDepPath);\n    if (await fileExists(path)) {\n      return path;\n    }\n  }\n\n  const nrwlWorkspaceDepPath = await workspaceDependencyPath(\n    workspacePath,\n    '@nrwl/workspace'\n  );\n  if (nrwlWorkspaceDepPath) {\n    const path = buildPath(nrwlWorkspaceDepPath);\n    if (await fileExists(path)) {\n      return path;\n    }\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"semver\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"nx/src/devkit-exports\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-json-languageservice\");","import { hasKey } from '@nx-console/shared/utils';\nimport { JSONSchema } from 'vscode-json-languageservice';\n\nexport const X_COMPLETION_TYPE = 'x-completion-type' as const;\nexport const X_COMPLETION_GLOB = 'x-completion-glob' as const;\n\nexport enum CompletionType {\n  file = 'file',\n  directory = 'directory',\n  // support for projectName:build auto complete\n  projectTarget = 'projectTarget',\n  projects = 'projects',\n  targets = 'targets',\n  // support for target with ^ (^build, build, etc)\n  targetsWithDeps = 'targetsWithDeps',\n  tags = 'tags',\n  inputName = 'inputName',\n  // support for input names with ^ (^production, production, etc)\n  inputNameWithDeps = 'inputNameWithDeps',\n}\n\nexport function hasCompletionType(\n  schema: JSONSchema\n): schema is JSONSchema & { [X_COMPLETION_TYPE]: CompletionType } {\n  return hasKey(schema, X_COMPLETION_TYPE);\n}\n\nexport function hasCompletionGlob(\n  schema: JSONSchema\n): schema is JSONSchema & { [X_COMPLETION_GLOB]: string } {\n  return hasKey(schema, X_COMPLETION_GLOB);\n}\n\ndeclare module 'vscode-json-languageservice' {\n  interface JSONSchema {\n    [X_COMPLETION_TYPE]?: CompletionType;\n    [X_COMPLETION_GLOB]?: string;\n  }\n}\n\nexport type EnhancedJsonSchema = JSONSchema;\n","import { JSONSchema } from 'vscode-json-languageservice';\nimport { CompletionType } from './completion-type';\nimport { NxVersion } from '@nx-console/shared/types';\n\nexport const implicitDependencies: JSONSchema = {\n  type: 'array',\n  items: {\n    type: 'string',\n    'x-completion-type': CompletionType.projects,\n  },\n};\n\nexport const outputs: JSONSchema = {\n  type: 'array',\n  items: {\n    type: 'string',\n    'x-completion-type': CompletionType.directory,\n  },\n};\n\nexport const inputs = (nxVersion: NxVersion): JSONSchema[] => [\n  { type: 'string', 'x-completion-type': CompletionType.inputNameWithDeps },\n  {\n    type: 'object',\n    properties: {\n      input: {\n        type: 'string',\n        'x-completion-type': CompletionType.inputName,\n      },\n      projects: projects(nxVersion),\n    },\n  },\n  {\n    type: 'object',\n    properties: {\n      fileset: {\n        type: 'string',\n      },\n    },\n  },\n  {\n    type: 'object',\n    properties: {\n      runtime: {\n        type: 'string',\n      },\n    },\n  },\n  {\n    type: 'object',\n    properties: {\n      env: {\n        type: 'string',\n      },\n    },\n  },\n];\n\nexport const namedInputs = (nxVersion: NxVersion): JSONSchema => ({\n  type: 'object',\n  additionalProperties: {\n    oneOf: inputs(nxVersion),\n  },\n});\n\nexport const tags: JSONSchema = {\n  type: 'array',\n  items: {\n    type: 'string',\n    'x-completion-type': CompletionType.tags,\n  },\n};\n\nconst projects = (nxVersion: NxVersion): JSONSchema => {\n  if (nxVersion.major < 16) {\n    return {\n      type: 'string',\n      enum: ['self', 'dependencies'],\n    };\n  } else {\n    return {\n      oneOf: [\n        {\n          type: 'string',\n          'x-completion-type': CompletionType.projects,\n        },\n        {\n          type: 'array',\n          items: {\n            type: 'string',\n            'x-completion-type': CompletionType.projects,\n          },\n        },\n      ],\n    };\n  }\n};\n\nexport const targets = (\n  nxVersion: NxVersion,\n  executors?: JSONSchema[]\n): JSONSchema => {\n  const schema: JSONSchema = {\n    additionalProperties: {\n      type: 'object',\n      properties: {\n        outputs,\n        ...(executors && { executor: { type: 'string' } }),\n        ...(executors && {\n          configurations: { additionalProperties: { type: 'object' } },\n        }),\n        dependsOn: {\n          type: 'array',\n          items: {\n            oneOf: [\n              {\n                type: 'string',\n                'x-completion-type': CompletionType.targetsWithDeps,\n              },\n              {\n                type: 'object',\n                properties: {\n                  projects: projects(nxVersion),\n                  target: {\n                    type: 'string',\n                    'x-completion-type': CompletionType.targets,\n                  },\n                  params: {\n                    type: 'string',\n                    enum: ['ignore', 'forward'],\n                  },\n                },\n              },\n            ],\n          },\n        },\n        inputs: {\n          type: 'array',\n          items: {\n            oneOf: inputs(nxVersion),\n          },\n        },\n      },\n      ...(executors && { allOf: executors }),\n    },\n  };\n\n  return schema;\n};\n","import { TargetConfiguration } from 'nx/src/devkit-exports';\nimport { CollectionInfo } from '@nx-console/shared/schema';\nimport { TargetDefaults } from 'nx/src/config/nx-json';\nimport type { JSONSchema } from 'vscode-json-languageservice';\nimport {\n  implicitDependencies,\n  namedInputs,\n  tags,\n  targets,\n} from './common-json-schema';\nimport { CompletionType, EnhancedJsonSchema } from './completion-type';\nimport { createBuildersAndExecutorsSchema } from './create-builders-and-executors-schema';\nimport { NxVersion } from '@nx-console/shared/types';\n\ntype JSONSchemaMap = NonNullable<JSONSchema['properties']>;\n\nexport function getProjectJsonSchema(\n  collections: CollectionInfo[],\n  targetDefaults: TargetDefaults = {},\n  nxVersion: NxVersion\n) {\n  const [, executors] = createBuildersAndExecutorsSchema(collections);\n  const contents = createJsonSchema(executors, targetDefaults, nxVersion);\n  return contents;\n}\n\nfunction createJsonSchema(\n  executors: JSONSchema[],\n  targetDefaults: TargetDefaults,\n  nxVersion: NxVersion\n): EnhancedJsonSchema {\n  const targetsSchema =\n    (targets(nxVersion, executors).additionalProperties as object) ?? {};\n  const targetsProperties = Object.keys(targetDefaults).reduce<JSONSchemaMap>(\n    (targets, target) => {\n      const defaults: Partial<TargetConfiguration> = targetDefaults[target];\n      let targetSchema: JSONSchema = targetsSchema;\n      if (defaults?.executor) {\n        const match = executors.find((schema) => {\n          const test = schema.if as JSONSchema;\n          const executor = test?.properties?.executor as JSONSchema;\n          return executor?.const === defaults.executor;\n        });\n        if (match) {\n          targetSchema = {\n            if: {\n              properties: { executor: { type: 'string' } },\n              required: ['executor'],\n            },\n            then: targetsSchema,\n            else: match.then,\n          };\n        }\n      }\n      targets[target] = targetSchema;\n      return targets;\n    },\n    {}\n  );\n  return {\n    type: 'object',\n    properties: {\n      sourceRoot: {\n        type: 'string',\n        'x-completion-type': CompletionType.directory,\n      },\n      implicitDependencies,\n      tags,\n      namedInputs: namedInputs(nxVersion),\n      targets: {\n        type: 'object',\n        properties: targetsProperties,\n        additionalProperties: targetsSchema,\n      },\n    },\n  };\n}\n","import { NxVersion } from '@nx-console/shared/types';\nimport {\n  implicitDependencies,\n  namedInputs,\n  tags,\n  targets,\n} from './common-json-schema';\nimport { EnhancedJsonSchema } from './completion-type';\n\nexport function getPackageJsonSchema(nxVersion: NxVersion) {\n  const contents = createJsonSchema(nxVersion);\n  return contents;\n}\n\nfunction createJsonSchema(nxVersion: NxVersion): EnhancedJsonSchema {\n  return {\n    type: 'object',\n    properties: {\n      nx: {\n        type: 'object',\n        properties: {\n          ignore: {\n            type: 'boolean',\n          },\n          namedInputs: namedInputs(nxVersion),\n          tags,\n          implicitDependencies,\n          targets: targets(nxVersion),\n        },\n      },\n    },\n  };\n}\n","import { CollectionInfo } from '@nx-console/shared/schema';\nimport type { ProjectConfiguration } from 'nx/src/devkit-exports';\nimport type { JSONSchema } from 'vscode-json-languageservice';\nimport { targets } from './common-json-schema';\nimport { CompletionType, EnhancedJsonSchema } from './completion-type';\nimport { createBuildersAndExecutorsSchema } from './create-builders-and-executors-schema';\nimport { NxVersion } from '@nx-console/shared/types';\n\ntype JSONSchemaMap = NonNullable<JSONSchema['properties']>;\n\nexport function getNxJsonSchema(\n  collections: CollectionInfo[],\n  projects: Record<string, ProjectConfiguration>,\n  nxVersion: NxVersion\n) {\n  const [, executors] = createBuildersAndExecutorsSchema(collections);\n  const targets = getTargets(projects);\n  const contents = createJsonSchema(executors, targets, nxVersion);\n  return contents;\n}\n\nfunction createJsonSchema(\n  executors: JSONSchema[],\n  projectTargets: string[],\n  nxVersion: NxVersion\n): EnhancedJsonSchema {\n  const targetsSchema =\n    (targets(nxVersion, executors).additionalProperties as object) ?? {};\n  return {\n    type: 'object',\n    properties: {\n      tasksRunnerOptions: {\n        type: 'object',\n        additionalProperties: {\n          type: 'object',\n          properties: {\n            options: {\n              type: 'object',\n              properties: {\n                cacheableOperations: {\n                  type: 'array',\n                  items: {\n                    type: 'string',\n                    'x-completion-type': CompletionType.targets,\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      targetDefaults: {\n        type: 'object',\n        properties: projectTargets.reduce<JSONSchemaMap>((acc, current) => {\n          acc[current] = {\n            type: 'object',\n            ...targetsSchema,\n          };\n          return acc;\n        }, {}),\n      },\n      targetDependencyConfig: {\n        type: 'array',\n        items: {\n          oneOf: [\n            {\n              type: 'string',\n              'x-completion-type': CompletionType.targetsWithDeps,\n            },\n            {\n              type: 'object',\n              properties: {\n                target: {\n                  type: 'string',\n                  description: 'The name of the target.',\n                  'x-completion-type': CompletionType.targets,\n                },\n              },\n            },\n          ],\n        },\n      },\n    },\n  };\n}\n\nfunction getTargets(projects: Record<string, ProjectConfiguration>): string[] {\n  const tags = new Set<string>();\n\n  for (const projectConfiguration of Object.values(projects)) {\n    for (const target of Object.keys(projectConfiguration.targets ?? {})) {\n      tags.add(target);\n    }\n  }\n\n  return Array.from(tags);\n}\n","import {\n  ArrayASTNode,\n  ASTNode,\n  ObjectASTNode,\n  PropertyASTNode,\n  StringASTNode,\n} from 'vscode-json-languageservice';\n\nexport function isPropertyNode(node?: ASTNode): node is PropertyASTNode {\n  return node?.type === 'property';\n}\n\nexport function isObjectNode(node?: ASTNode): node is ObjectASTNode {\n  return node?.type === 'object';\n}\n\nexport function isStringNode(node?: ASTNode): node is StringASTNode {\n  return node?.type === 'string';\n}\n\nexport function isArrayNode(node?: ASTNode): node is ArrayASTNode {\n  return node?.type === 'array';\n}\n","import { CompletionType } from '@nx-console/shared/json-schema';\nimport { ASTNode } from 'vscode-json-languageservice';\nimport { isPropertyNode, isStringNode } from './node-types';\n\ntype DefaultCompletion = { glob?: string; completionType: CompletionType };\n\nconst defaultCompletionMap = new Map<string, DefaultCompletion>();\n\ndefaultCompletionMap.set('jestconfig', {\n  glob: 'jest.config.@(js|ts)',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('index', {\n  glob: '*.html',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('polyfills', {\n  glob: '*.ts',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('main', {\n  glob: '*.ts',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('tsconfig', {\n  glob: 'tsconfig.*.json',\n  completionType: CompletionType.file,\n});\ndefaultCompletionMap.set('outputpath', {\n  completionType: CompletionType.directory,\n});\ndefaultCompletionMap.set('browsertarget', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('servertarget', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('buildtarget', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('target', {\n  completionType: CompletionType.projectTarget,\n});\ndefaultCompletionMap.set('devservertarget', {\n  completionType: CompletionType.projectTarget,\n});\n\nexport function getDefaultCompletionType(\n  node: ASTNode\n): DefaultCompletion | undefined {\n  const parent = node.parent;\n  if (isPropertyNode(parent) && isStringNode(parent.keyNode)) {\n    const key = parent.keyNode.value.toLowerCase();\n    return defaultCompletionMap.get(key);\n  }\n\n  return undefined;\n}\n\nexport function hasDefaultCompletionType(node: ASTNode): boolean {\n  const parent = node.parent;\n  if (isPropertyNode(parent) && isStringNode(parent.keyNode)) {\n    const key = parent.keyNode.value.toLowerCase();\n    return defaultCompletionMap.has(key);\n  }\n\n  return false;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"rxjs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.string.match.js\");","import { Logger } from '@nx-console/shared/schema';\nimport { Connection } from 'vscode-languageserver';\n\nlet log: Console['log'] | undefined;\n\nexport function setLspLogger(connection: Connection) {\n  if (!log) {\n    log = connection.console.log.bind(connection.console);\n  } else {\n    throw `Can't set logger twice`;\n  }\n}\n\nexport const lspLogger: Logger = {\n  log(message: string, ...args: any[]) {\n    log?.(\n      `[Nxls] - ${new Date(Date.now()).toISOString()} - ${message}\\n`,\n      ...args\n    );\n  },\n};\n","// import { getOutputChannel } from '@nx-console/utils';\nimport type * as NxFileUtils from 'nx/src/project-graph/file-utils';\nimport type * as NxProjectGraph from 'nx/src/project-graph/project-graph';\nimport type * as NxDaemonClient from 'nx/src/daemon/client/client';\nimport type * as NxOutput from 'nx/src/utils/output';\nimport { platform } from 'os';\nimport { join } from 'path';\nimport { findNxPackagePath } from '@nx-console/shared/npm';\nimport { Logger } from '@nx-console/shared/schema';\n\nexport async function getNxDaemonClient(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxDaemonClient> {\n  const importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'daemon', 'client', 'client.js')\n  );\n  return getNxPackage(importPath, logger);\n}\n\nexport async function getNxOutput(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxOutput | undefined> {\n  const importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'utils', 'output.js')\n  );\n\n  if (!importPath) {\n    return;\n  }\n\n  return getNxPackage(importPath, logger);\n}\n\nexport async function getNxProjectGraph(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxProjectGraph> {\n  let importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'project-graph', 'project-graph.js')\n  );\n\n  if (!importPath) {\n    importPath = await findNxPackagePath(\n      workspacePath,\n      join('src', 'core', 'project-graph', 'project-graph.js')\n    );\n  }\n\n  return getNxPackage(importPath, logger);\n}\n\n/**\n * Get the local installed version of @nx/workspace\n */\nexport async function getNxWorkspacePackageFileUtils(\n  workspacePath: string,\n  logger: Logger\n): Promise<typeof NxFileUtils> {\n  let importPath = await findNxPackagePath(\n    workspacePath,\n    join('src', 'project-graph', 'file-utils.js')\n  );\n\n  if (!importPath) {\n    importPath = await findNxPackagePath(\n      workspacePath,\n      join('src', 'core', 'file-utils.js')\n    );\n  }\n\n  return getNxPackage(importPath, logger);\n}\n\nasync function getNxPackage<T>(\n  importPath: string | undefined,\n  logger: Logger\n): Promise<T> {\n  if (!importPath) {\n    logger?.log(\n      `Unable to load the ${importPath} dependency from the workspace. Please ensure that the proper dependencies are installed locally.`\n    );\n    throw 'local Nx dependency not found';\n  }\n\n  if (platform() === 'win32') {\n    importPath = importPath.replace(/\\\\/g, '/');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const imported = require(importPath);\n\n  logger?.log(`Using local Nx package at ${importPath}`);\n\n  return imported;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"perf_hooks\");","import type {\n  NxJsonConfiguration,\n  ProjectGraph,\n  ProjectsConfigurations,\n} from 'nx/src/devkit-exports';\nimport { lspLogger } from '@nx-console/language-server/utils';\nimport { readAndCacheJsonFile } from '@nx-console/shared/file-system';\nimport { Logger } from '@nx-console/shared/schema';\nimport { NxWorkspaceConfiguration } from '@nx-console/shared/types';\nimport { join } from 'path';\nimport { SemVer } from 'semver';\nimport {\n  getNxOutput,\n  getNxProjectGraph,\n  getNxWorkspacePackageFileUtils,\n} from './get-nx-workspace-package';\nimport { performance } from 'perf_hooks';\n\nlet projectGraph: ProjectGraph | null = null;\n\nexport async function getNxWorkspaceConfig(\n  workspacePath: string,\n  nxVersion: SemVer,\n  logger: Logger\n): Promise<{\n  workspaceConfiguration: NxWorkspaceConfiguration;\n  daemonEnabled?: boolean;\n}> {\n  const start = performance.now();\n  logger.log('Retrieving workspace configuration');\n\n  if (nxVersion.major < 12) {\n    lspLogger.log('Major version is less than 12');\n    return readWorkspaceConfigs(workspacePath);\n  }\n\n  try {\n    // Always set the CI env variable to false\n    (process.env as any).CI = false;\n    (process.env as any).NX_PROJECT_GLOB_CACHE = false;\n    (process.env as any).NX_WORKSPACE_ROOT_PATH = workspacePath;\n    const [nxWorkspacePackage, nxProjectGraph, nxOutput] = await Promise.all([\n      getNxWorkspacePackageFileUtils(workspacePath, logger),\n      getNxProjectGraph(workspacePath, logger),\n      getNxOutput(workspacePath, logger),\n    ]);\n\n    let workspaceConfiguration: NxWorkspaceConfiguration;\n    try {\n      workspaceConfiguration = nxWorkspacePackage.readWorkspaceConfig({\n        format: 'nx',\n        path: workspacePath,\n      });\n    } catch {\n      logger.log('Unable to read workspace config from nx workspace package');\n      workspaceConfiguration = (await readWorkspaceConfigs(workspacePath))\n        .workspaceConfiguration;\n    }\n\n    try {\n      process.exit = function (code?: number) {\n        console.warn('process.exit called with code', code);\n      } as (code?: number) => never;\n\n      if (nxOutput !== undefined) {\n        nxOutput.output.error = (output) => {\n          // do nothing\n        };\n      }\n\n      if (nxVersion.major < 13) {\n        projectGraph = (nxProjectGraph as any).createProjectGraph();\n      } else {\n        lspLogger.log('createProjectGraphAsync');\n        projectGraph = await nxProjectGraph.createProjectGraphAsync({\n          exitOnError: false,\n          resetDaemonClient: true,\n        });\n        lspLogger.log('createProjectGraphAsync successful');\n      }\n    } catch (e) {\n      lspLogger.log('Unable to get project graph');\n      lspLogger.log(e.stack);\n    }\n\n    workspaceConfiguration = addProjectTargets(\n      workspaceConfiguration,\n      projectGraph\n    );\n\n    const end = performance.now();\n    logger.log(`Retrieved workspace configuration in: ${end - start} ms`);\n\n    return {\n      workspaceConfiguration,\n    };\n  } catch (e) {\n    lspLogger.log(`Unable to get nx workspace configuration: ${e}`);\n    return readWorkspaceConfigs(workspacePath);\n  }\n}\n\nasync function readWorkspaceConfigs(basedir: string) {\n  const workspaceJson: ProjectsConfigurations = (\n    await readAndCacheJsonFile('workspace.json', basedir)\n  ).json;\n\n  const nxJson: NxJsonConfiguration = (\n    await readAndCacheJsonFile('nx.json', basedir)\n  ).json;\n  return {\n    workspaceConfiguration: {\n      ...workspaceJson,\n      ...nxJson,\n      projects: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ...((nxJson as any).projects ?? {}),\n        ...workspaceJson.projects,\n      },\n    },\n    configPath: join(basedir, 'workspace.json'),\n  };\n}\n\nfunction addProjectTargets(\n  workspaceConfiguration: NxWorkspaceConfiguration,\n  projectGraph: ProjectGraph | null\n) {\n  if (!projectGraph) {\n    return workspaceConfiguration;\n  }\n\n  // We always want to get the latest projects from the graph, rather than the ones in the workspace configuration\n  const modifiedWorkspaceConfiguration: NxWorkspaceConfiguration = {\n    ...workspaceConfiguration,\n    projects: {},\n  };\n\n  for (const [projectName, node] of Object.entries(projectGraph.nodes)) {\n    const workspaceProject = workspaceConfiguration.projects[projectName];\n\n    if (!workspaceProject) {\n      // Certain versions of Nx will include npm, (or other third party dependencies) in the project graph nodes.\n      // These usually start with `npm:depname`\n      // We dont want to include them.\n      if (projectName.match(/:/)) {\n        continue;\n      }\n\n      modifiedWorkspaceConfiguration.projects[projectName] = {\n        root: node.data.root,\n        targets: node.data.targets ?? {},\n        name: projectName,\n        tags: node.data.tags ?? [],\n        files: node.data.files ?? [],\n      };\n    } else {\n      modifiedWorkspaceConfiguration.projects[projectName] = {\n        ...workspaceProject,\n        targets: node.data.targets ?? {},\n        files: node.data.files ?? [],\n        name: projectName,\n      };\n    }\n  }\n\n  return modifiedWorkspaceConfiguration;\n}\n","import { findNxPackagePath } from '@nx-console/shared/npm';\nimport { coerce, SemVer } from 'semver';\n\nlet nxWorkspacePackageJson: { version: string };\nlet loadedNxPackage = false;\n\nconst defaultSemver = new SemVer('0.0.0');\n\nexport async function getNxVersion(workspacePath: string): Promise<SemVer> {\n  if (!loadedNxPackage) {\n    const packagePath = await findNxPackagePath(workspacePath, 'package.json');\n\n    if (!packagePath) {\n      return defaultSemver;\n    }\n\n    nxWorkspacePackageJson = require(packagePath);\n    loadedNxPackage = true;\n  }\n\n  if (!nxWorkspacePackageJson) {\n    return defaultSemver;\n  }\n  const nxVersion = coerce(nxWorkspacePackageJson.version);\n  if (!nxVersion) {\n    return defaultSemver;\n  }\n\n  return nxVersion;\n}\n","import { formatError, sortWorkspaceProjects } from '@nx-console/shared/utils';\n\nimport { clearJsonCache, fileExists } from '@nx-console/shared/file-system';\nimport { Logger } from '@nx-console/shared/schema';\nimport { join } from 'path';\nimport {\n  firstValueFrom,\n  from,\n  iif,\n  of,\n  ReplaySubject,\n  switchMap,\n  tap,\n} from 'rxjs';\nimport { getNxWorkspaceConfig } from './get-nx-workspace-config';\nimport { NxWorkspace } from '@nx-console/shared/types';\nimport { getNxVersion } from './get-nx-version';\n\nconst enum Status {\n  not_started,\n  in_progress,\n  cached,\n}\n\nlet cachedReplay = new ReplaySubject<NxWorkspace>();\nlet status: Status = Status.not_started;\n\nfunction resetStatus(workspacePath: string) {\n  status = Status.not_started;\n  cachedReplay = new ReplaySubject<NxWorkspace>();\n  // Clear out the workspace config path, needed for older nx workspaces\n  clearJsonCache('workspace.json', workspacePath);\n  clearJsonCache('nx.json', workspacePath);\n}\n\nexport async function nxWorkspace(\n  workspacePath: string,\n  logger: Logger = {\n    log(message) {\n      console.log(message);\n    },\n  },\n  reset?: boolean\n): Promise<NxWorkspace> {\n  if (reset) {\n    resetStatus(workspacePath);\n  }\n\n  return firstValueFrom(\n    iif(\n      () => status === Status.not_started,\n      of({}).pipe(\n        tap(() => {\n          status = Status.in_progress;\n        }),\n        switchMap(() => from(_workspace(workspacePath, logger))),\n        tap((workspace) => {\n          cachedReplay.next(workspace);\n          status = Status.cached;\n        })\n      ),\n      cachedReplay\n    )\n  );\n}\n\nasync function _workspace(\n  workspacePath: string,\n  logger: Logger\n): Promise<NxWorkspace> {\n  try {\n    const version = await getNxVersion(workspacePath);\n    const config = await getNxWorkspaceConfig(workspacePath, version, logger);\n\n    const isLerna = await fileExists(join(workspacePath, 'lerna.json'));\n    return {\n      validWorkspaceJson: true,\n      workspace: sortWorkspaceProjects(config.workspaceConfiguration),\n      daemonEnabled: config.daemonEnabled,\n      isLerna,\n      isEncapsulatedNx: !!config.workspaceConfiguration.installation,\n      workspaceLayout: {\n        appsDir: config.workspaceConfiguration.workspaceLayout?.appsDir,\n        libsDir: config.workspaceConfiguration.workspaceLayout?.libsDir,\n      },\n      nxVersion: {\n        major: version.major,\n        minor: version.minor,\n        full: version.version,\n      },\n      workspacePath,\n    };\n  } catch (e) {\n    logger.log(formatError('Invalid workspace', e));\n\n    // Default to nx workspace\n    return {\n      validWorkspaceJson: false,\n      workspace: {\n        npmScope: '@nx-console',\n        projects: {},\n        version: 2,\n      },\n      workspacePath,\n      isEncapsulatedNx: false,\n      nxVersion: {\n        major: 0,\n        minor: 0,\n        full: '0.0.0',\n      },\n      isLerna: false,\n      workspaceLayout: {\n        appsDir: 'apps',\n        libsDir: 'libs',\n      },\n    };\n  }\n}\n","import {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\n\nexport function createCompletionItem(\n  label: string,\n  path: string,\n  node: ASTNode,\n  document: TextDocument,\n  kind: CompletionItemKind,\n  documentation?: string\n): CompletionItem {\n  const startPosition = document.positionAt(node.offset);\n  const endPosition = document.positionAt(node.offset + node.length);\n  label = `\"${label}\"`;\n  return {\n    label,\n    documentation,\n    kind,\n    insertText: label,\n    insertTextFormat: 2,\n    textEdit: {\n      newText: label,\n      range: {\n        start: startPosition,\n        end: endPosition,\n      },\n    },\n    detail: path,\n  };\n}\n","import { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function inputNameCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument,\n  hasDependencyHat = false\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const inputNameCompletion: CompletionItem[] = [];\n\n  const { workspace } = await nxWorkspace(workingPath);\n\n  for (const inputName of Object.keys(workspace.namedInputs ?? {})) {\n    if (hasDependencyHat) {\n      inputNameCompletion.push(\n        createCompletionItem(\n          `^${inputName}`,\n          '',\n          node,\n          document,\n          CompletionItemKind.Property,\n          `Base \"${inputName}\" on this project's dependencies`\n        )\n      );\n    }\n    inputNameCompletion.push(\n      createCompletionItem(\n        inputName,\n        '',\n        node,\n        document,\n        CompletionItemKind.Property\n      )\n    );\n  }\n\n  return inputNameCompletion;\n}\n","import { ASTNode } from 'vscode-json-languageservice';\nimport { isObjectNode, isPropertyNode, isStringNode } from './node-types';\n\n/**\n * Get the first `root` property from the current node to determine `${projectRoot}`\n * @param node\n * @returns\n */\nexport function findProjectRoot(node: ASTNode): string {\n  if (isObjectNode(node)) {\n    for (const child of node.children) {\n      if (isPropertyNode(child)) {\n        if (\n          (child.keyNode.value === 'root' ||\n            child.keyNode.value === 'sourceRoot') &&\n          isStringNode(child.valueNode)\n        ) {\n          return child.valueNode?.value;\n        }\n      }\n    }\n  }\n\n  if (node.parent) {\n    return findProjectRoot(node.parent);\n  }\n\n  return '';\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fast-glob\");","import {\n  findProjectRoot,\n  isStringNode,\n} from '@nx-console/language-server/utils';\nimport fastGlob from 'fast-glob';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function pathCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument,\n  options?: {\n    glob: string;\n    searchType: 'file' | 'directory';\n    supportsInterpolation?: boolean;\n  }\n): Promise<CompletionItem[]> {\n  const items: CompletionItem[] = [];\n\n  if (!workingPath) {\n    return items;\n  }\n\n  const { supportsInterpolation, glob, searchType } = {\n    supportsInterpolation: false,\n    ...options,\n  };\n\n  if (!isStringNode(node)) {\n    return items;\n  }\n\n  const projectRoot = findProjectRoot(node);\n\n  const files = await fastGlob([workingPath + '/**/' + glob], {\n    ignore: ['**/node_modules/**'],\n    dot: true,\n    onlyFiles: searchType === 'file',\n    onlyDirectories: searchType === 'directory',\n    objectMode: true,\n  });\n\n  const completionKind =\n    searchType === 'directory'\n      ? CompletionItemKind.Folder\n      : CompletionItemKind.File;\n\n  for (const file of files) {\n    if (\n      supportsInterpolation &&\n      file.path.startsWith(workingPath + '/' + projectRoot)\n    ) {\n      const label =\n        '{projectRoot}' +\n        file.path.replace(workingPath + '/' + projectRoot, '');\n\n      items.push(\n        createCompletionItem(label, file.path, node, document, completionKind)\n      );\n    }\n\n    if (file.path.startsWith(workingPath)) {\n      const label = file.path.replace(workingPath + '/', '');\n\n      if (supportsInterpolation) {\n        const label = '{workspaceRoot}' + file.path.replace(workingPath, '');\n        items.push(\n          createCompletionItem(label, file.path, node, document, completionKind)\n        );\n      } else {\n        items.push(\n          createCompletionItem(label, file.path, node, document, completionKind)\n        );\n      }\n    }\n  }\n\n  return items;\n}\n","import { isArrayNode } from '@nx-console/language-server/utils';\nimport { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function tagsCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const tagCompletion: CompletionItem[] = [];\n\n  const { workspace } = await nxWorkspace(workingPath);\n  const tags = new Set<string>();\n  for (const projectConfiguration of Object.values(workspace.projects)) {\n    for (const tag of projectConfiguration.tags ?? []) {\n      tags.add(tag);\n    }\n  }\n\n  const existingTags = getTagsOnCurrentNode(node);\n\n  for (const tag of tags) {\n    if (existingTags.has(tag)) {\n      continue;\n    }\n\n    tagCompletion.push(\n      createCompletionItem(tag, '', node, document, CompletionItemKind.Constant)\n    );\n  }\n\n  return tagCompletion;\n}\n\nfunction getTagsOnCurrentNode(node: ASTNode): Set<string> {\n  const parent = node.parent;\n  if (!isArrayNode(parent)) {\n    return new Set();\n  }\n\n  return new Set(parent.items.map((item) => item.value as string));\n}\n","import { isArrayNode } from '@nx-console/language-server/utils';\nimport { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function targetsCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument,\n  hasDependencyHat = false\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const targetsCompletion: CompletionItem[] = [];\n  const { workspace } = await nxWorkspace(workingPath);\n\n  const targetNames = new Set<string>();\n  for (const project of Object.values(workspace.projects)) {\n    for (const targetName of Object.keys(project.targets ?? {})) {\n      targetNames.add(targetName);\n    }\n  }\n\n  const existingTargets = getTargetsOnCurrentNode(node);\n\n  for (const targetName of targetNames) {\n    if (existingTargets.has(targetName)) {\n      continue;\n    }\n\n    if (hasDependencyHat) {\n      const dependencyHat = `^${targetName}`;\n      if (existingTargets.has(dependencyHat)) {\n        continue;\n      }\n\n      targetsCompletion.push(\n        createCompletionItem(\n          dependencyHat,\n          '',\n          node,\n          document,\n          CompletionItemKind.Field,\n          `Run all dependencies that have \"${targetName}\" as a target before this one`\n        )\n      );\n    }\n    targetsCompletion.push(\n      createCompletionItem(\n        targetName,\n        '',\n        node,\n        document,\n        CompletionItemKind.Field\n      )\n    );\n  }\n\n  return targetsCompletion;\n}\n\nfunction getTargetsOnCurrentNode(node: ASTNode) {\n  const parent = node.parent;\n  if (!isArrayNode(parent)) {\n    return new Set();\n  }\n\n  return new Set(parent.items.map((item) => item.value as string));\n}\n","import {\n  CompletionType,\n  hasCompletionGlob,\n  hasCompletionType,\n  X_COMPLETION_GLOB,\n  X_COMPLETION_TYPE,\n} from '@nx-console/shared/json-schema';\nimport {\n  getDefaultCompletionType,\n  isArrayNode,\n} from '@nx-console/language-server/utils';\nimport {\n  ASTNode,\n  CompletionItem,\n  JSONDocument,\n  MatchingSchema,\n  Position,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { inputNameCompletion } from './input-name-completion';\nimport { pathCompletion } from './path-completion';\nimport { projectCompletion } from './project-completion';\nimport { projectTargetCompletion } from './project-target-completion';\nimport { tagsCompletion } from './tags-completion';\nimport { targetsCompletion } from './targets-completion';\nimport { NxVersion } from '@nx-console/shared/types';\n\nexport async function getCompletionItems(\n  workingPath: string | undefined,\n  nxVersion: NxVersion,\n  jsonAst: JSONDocument,\n  document: TextDocument,\n  schemas: MatchingSchema[],\n  position: Position\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const offset = document.offsetAt(position);\n  const node = jsonAst.getNodeFromOffset(offset);\n  if (!node) {\n    return [];\n  }\n\n  const items = completionItems(workingPath, nxVersion, node, document);\n\n  let resolvedItems: CompletionItem[] = [];\n\n  for (const { schema, node: schemaNode } of schemas) {\n    // Find the schema node that matches the current node\n    // If the node is found, then we will return the whole function so that we don't have to loop over the rest of the items.\n    if (schemaNode == node) {\n      if (hasCompletionType(schema)) {\n        const completion = schema[X_COMPLETION_TYPE];\n        if (hasCompletionGlob(schema)) {\n          resolvedItems = await items(completion, schema[X_COMPLETION_GLOB]);\n          break;\n        }\n\n        resolvedItems = await items(completion);\n        break;\n      }\n    }\n  }\n\n  const defaultCompletion = getDefaultCompletionType(node);\n\n  if (defaultCompletion && resolvedItems.length === 0) {\n    resolvedItems = await items(\n      defaultCompletion.completionType,\n      defaultCompletion.glob\n    );\n  }\n\n  // remove duplicate values from the resolved completed items\n  if (isArrayNode(node.parent)) {\n    const existingItems = node.parent.children.map((i) =>\n      JSON.stringify(i.value)\n    );\n    resolvedItems = resolvedItems.filter(\n      (resolvedItem) => !existingItems.includes(resolvedItem.label)\n    );\n  }\n\n  return resolvedItems;\n}\n\nfunction completionItems(\n  workingPath: string,\n  nxVersion: NxVersion,\n  node: ASTNode,\n  document: TextDocument\n) {\n  return async (\n    completion: CompletionType,\n    glob?: string\n  ): Promise<CompletionItem[]> => {\n    // const supportsInterpolation = nxVersion.major >= 16;\n    // todo(jcammisuli): change this once executors support {workspaceRoot} and {projectRoot} in their options\n    const supportsInterpolation = false;\n    switch (completion) {\n      case CompletionType.file: {\n        return pathCompletion(workingPath, node, document, {\n          glob: glob ?? '*.*',\n          searchType: 'file',\n          supportsInterpolation,\n        });\n      }\n      case CompletionType.directory: {\n        return pathCompletion(workingPath, node, document, {\n          glob: glob ?? '*',\n          searchType: 'directory',\n          supportsInterpolation,\n        });\n      }\n      case CompletionType.projectTarget: {\n        return projectTargetCompletion(workingPath, node, document);\n      }\n      case CompletionType.projects: {\n        return projectCompletion(workingPath, node, document);\n      }\n      case CompletionType.tags: {\n        return tagsCompletion(workingPath, node, document);\n      }\n      case CompletionType.targets: {\n        return targetsCompletion(workingPath, node, document);\n      }\n      case CompletionType.targetsWithDeps: {\n        return targetsCompletion(workingPath, node, document, true);\n      }\n      case CompletionType.inputName: {\n        return inputNameCompletion(workingPath, node, document);\n      }\n      case CompletionType.inputNameWithDeps: {\n        return inputNameCompletion(workingPath, node, document, true);\n      }\n      default: {\n        return [];\n      }\n    }\n  };\n}\n","import { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function projectTargetCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const { workspace } = await nxWorkspace(workingPath);\n\n  const projectTargetCompletion: CompletionItem[] = [];\n\n  const completionItemKind = CompletionItemKind.Field;\n\n  for (const [projectName, configuration] of Object.entries(\n    workspace.projects\n  )) {\n    for (const [targetName, target] of Object.entries(\n      configuration.targets ?? {}\n    )) {\n      const targetLabel = `${projectName}:${targetName}`;\n      projectTargetCompletion.push(\n        createCompletionItem(\n          targetLabel,\n          '',\n          node,\n          document,\n          completionItemKind\n        )\n      );\n\n      for (const configuration of Object.keys(target.configurations ?? {})) {\n        const configurationLabel = `${targetLabel}:${configuration}`;\n        projectTargetCompletion.push(\n          createCompletionItem(\n            configurationLabel,\n            '',\n            node,\n            document,\n            completionItemKind\n          )\n        );\n      }\n    }\n  }\n\n  return projectTargetCompletion;\n}\n","import { nxWorkspace } from '@nx-console/language-server/workspace';\nimport {\n  ASTNode,\n  CompletionItem,\n  CompletionItemKind,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createCompletionItem } from './create-completion-path-item';\n\nexport async function projectCompletion(\n  workingPath: string | undefined,\n  node: ASTNode,\n  document: TextDocument\n): Promise<CompletionItem[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const { workspace } = await nxWorkspace(workingPath);\n\n  const projectCompletion: CompletionItem[] = [];\n\n  for (const projectName of Object.keys(workspace.projects)) {\n    projectCompletion.push(\n      createCompletionItem(\n        projectName,\n        '',\n        node,\n        document,\n        CompletionItemKind.Struct\n      ),\n      createCompletionItem(\n        `!${projectName}`,\n        '',\n        node,\n        document,\n        CompletionItemKind.Struct,\n        `Exclude \"${projectName}\" from this project's dependencies`\n      )\n    );\n  }\n\n  return projectCompletion;\n}\n","import { ASTNode, Range, TextDocument } from 'vscode-json-languageservice';\n\nexport function createRange(document: TextDocument, node: ASTNode) {\n  const position = document.positionAt(node.offset);\n  const endPosition = document.positionAt(node.offset + node.length);\n  return Range.create(position, endPosition);\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@nx/devkit/src/executors/parse-target-string\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-languageserver-textdocument\");","import {\n  getLanguageService,\n  LanguageService,\n  LanguageServiceParams,\n  LanguageSettings,\n} from 'vscode-json-languageservice';\nimport { lspLogger } from './lsp-log';\n\nlet languageService: LanguageService | undefined;\n\nexport function configureJsonLanguageService(\n  params: LanguageServiceParams,\n  settings: LanguageSettings\n) {\n  languageService = getLanguageService(params);\n  languageService.configure(settings);\n\n  return languageService;\n}\n\nexport function getJsonLanguageService(): LanguageService | undefined {\n  if (!languageService) {\n    lspLogger.log('Language service not configured');\n  }\n\n  return languageService;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// https://github.com/microsoft/vscode/blob/89c30e1b86f941db095d9f52b128287e5039e004/extensions/json-language-features/server/src/languageModelCache.ts\n\nimport { JSONDocument } from 'vscode-json-languageservice';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { getJsonLanguageService } from './json-language-service';\n\nexport interface LanguageModelCache<T> {\n  retrieve(\n    document: TextDocument,\n    stripSchema?: boolean\n  ): { jsonAst: T; document: TextDocument };\n  onDocumentRemoved(document: TextDocument): void;\n  dispose(): void;\n}\n\nconst parse = (document: TextDocument): JSONDocument | undefined =>\n  getJsonLanguageService()?.parseJSONDocument(document);\n\nlet languageModels: {\n  [uri: string]: {\n    version: number;\n    languageId: string;\n    cTime: number;\n    languageModel: JSONDocument;\n    document: TextDocument;\n  };\n} = {};\nconst maxEntries = 10;\nconst cleanupIntervalTimeInSec = 60;\nlet nModels = 0;\n\nlet cleanupInterval: NodeJS.Timer | undefined = undefined;\nif (cleanupIntervalTimeInSec > 0) {\n  cleanupInterval = setInterval(() => {\n    const cutoffTime = Date.now() - cleanupIntervalTimeInSec * 1000;\n    const uris = Object.keys(languageModels);\n    for (const uri of uris) {\n      const languageModelInfo = languageModels[uri];\n      if (languageModelInfo.cTime < cutoffTime) {\n        delete languageModels[uri];\n        nModels--;\n      }\n    }\n  }, cleanupIntervalTimeInSec * 1000);\n}\n\nexport function getLanguageModelCache(): LanguageModelCache<JSONDocument> {\n  return {\n    retrieve(\n      document: TextDocument,\n      stripSchema = true\n    ): {\n      jsonAst: JSONDocument;\n      document: TextDocument;\n    } {\n      const version = document.version;\n      const languageId = document.languageId;\n      const languageModelInfo = languageModels[document.uri];\n      if (\n        languageModelInfo &&\n        languageModelInfo.version === version &&\n        languageModelInfo.languageId === languageId\n      ) {\n        languageModelInfo.cTime = Date.now();\n        return {\n          jsonAst: languageModelInfo.languageModel,\n          document: languageModelInfo.document,\n        };\n      }\n\n      if (stripSchema) {\n        document = TextDocument.create(\n          document.uri,\n          document.languageId,\n          document.version,\n          document.getText().replace(/\"\\$schema\":\\s\".+\",/, '')\n        );\n      }\n\n      const languageModel = parse(document);\n\n      if (!languageModel) {\n        return {\n          jsonAst: {\n            root: undefined,\n            getNodeFromOffset() {\n              return undefined;\n            },\n          },\n          document,\n        };\n      }\n\n      languageModels[document.uri] = {\n        languageModel,\n        version,\n        languageId,\n        document,\n        cTime: Date.now(),\n      };\n      if (!languageModelInfo) {\n        nModels++;\n      }\n\n      if (nModels === maxEntries) {\n        let oldestTime = Number.MAX_VALUE;\n        let oldestUri = null;\n        for (const uri in languageModels) {\n          const languageModelInfo = languageModels[uri];\n          if (languageModelInfo.cTime < oldestTime) {\n            oldestUri = uri;\n            oldestTime = languageModelInfo.cTime;\n          }\n        }\n        if (oldestUri) {\n          delete languageModels[oldestUri];\n          nModels--;\n        }\n      }\n      return { jsonAst: languageModel, document };\n    },\n    onDocumentRemoved(document: TextDocument) {\n      const uri = document.uri;\n      if (languageModels[uri]) {\n        delete languageModels[uri];\n        nModels--;\n      }\n    },\n    dispose() {\n      if (typeof cleanupInterval !== 'undefined') {\n        clearInterval(cleanupInterval);\n        cleanupInterval = undefined;\n        languageModels = {};\n        nModels = 0;\n      }\n    },\n  };\n}\n","import { ASTNode } from 'vscode-json-languageservice';\nimport { isObjectNode, isPropertyNode } from './node-types';\n\n/**\n * Find the first property from the current node\n * @param node\n * @param property\n */\nexport function findProperty(\n  node: ASTNode | undefined,\n  property: string\n): ASTNode | undefined {\n  if (isPropertyNode(node) && node.valueNode) {\n    node = node.valueNode;\n  }\n\n  if (isObjectNode(node)) {\n    for (const child of node.properties) {\n      if (child.keyNode.value === property) {\n        return child;\n      }\n\n      if (isObjectNode(child.valueNode)) {\n        const found = findProperty(child.valueNode, property);\n        if (found) {\n          return found;\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-uri\");","import { parseTargetString } from '@nx/devkit/src/executors/parse-target-string';\nimport { fileExists, readFile } from '@nx-console/shared/file-system';\nimport {\n  findProperty,\n  getLanguageModelCache,\n  isStringNode,\n  lspLogger,\n} from '@nx-console/language-server/utils';\nimport { nxWorkspace } from '@nx-console/language-server/workspace';\nimport { join } from 'path';\nimport {\n  ASTNode,\n  JSONDocument,\n  Range,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { URI } from 'vscode-uri';\nimport { createRange } from './create-range';\n\nconst tempDocumentCounter = new Map<string, number>();\n\nexport async function targetLink(\n  workingPath: string,\n  node: ASTNode\n): Promise<string | undefined> {\n  if (!isStringNode(node)) {\n    return;\n  }\n\n  const targetString = node.value;\n  let project, target, configuration;\n  try {\n    const parsedTargets = parseTargetString(targetString);\n    project = parsedTargets.project;\n    target = parsedTargets.target;\n    configuration = parsedTargets.configuration;\n  } catch (e) {\n    return;\n  }\n\n  const { workspace } = await nxWorkspace(workingPath, lspLogger);\n\n  const workspaceProject = workspace.projects[project];\n\n  if (!workspaceProject) {\n    lspLogger.log(`Could not find project ${project}`);\n    return;\n  }\n\n  const baseTargetPath = join(workingPath, workspaceProject.root);\n  const baseTargetProjectPath = join(baseTargetPath, 'project.json');\n\n  if (!(await fileExists(baseTargetProjectPath))) {\n    lspLogger.log(`Could not find target project: ${baseTargetProjectPath}`);\n    return;\n  }\n\n  const projectJson = await readFile(baseTargetProjectPath);\n\n  let versionNumber = 0;\n  if (tempDocumentCounter.has(baseTargetProjectPath)) {\n    versionNumber = tempDocumentCounter.get(baseTargetProjectPath) ?? 0;\n    tempDocumentCounter.set(baseTargetProjectPath, versionNumber + 1);\n  } else {\n    tempDocumentCounter.set(baseTargetProjectPath, versionNumber);\n  }\n\n  const { document, jsonAst } = getLanguageModelCache().retrieve(\n    TextDocument.create(\n      baseTargetProjectPath,\n      'json',\n      versionNumber,\n      projectJson\n    ),\n    false\n  );\n\n  const range = findTargetRange(document, jsonAst, target, configuration);\n\n  if (!range) {\n    return;\n  }\n\n  return URI.from({\n    scheme: 'file',\n    path: baseTargetProjectPath,\n    fragment: `${range.start.line + 1}`,\n  }).toString();\n}\n\nfunction findTargetRange(\n  document: TextDocument,\n  jsonAst: JSONDocument,\n  target: string,\n  configuration: string | undefined\n): Range | undefined {\n  if (!jsonAst.root) {\n    return;\n  }\n\n  const targetNode = findProperty(jsonAst.root, 'targets');\n\n  if (!targetNode) {\n    return;\n  }\n\n  // Find the target within the target object\n  const targetProperty = findProperty(targetNode, target);\n\n  if (!targetProperty) {\n    return;\n  }\n\n  if (configuration) {\n    const configurationNode = findProperty(targetProperty, configuration);\n\n    if (configurationNode) {\n      return createRange(document, configurationNode);\n    }\n  } else {\n    return createRange(document, targetProperty);\n  }\n}\n","import { crossFs } from './cache-json';\n\nexport async function readFile(filePath: string): Promise<string> {\n  try {\n    return crossFs.readFilePromise(filePath, 'utf8');\n  } catch {\n    return '';\n  }\n}\n","import {\n  ASTNode,\n  JSONDocument,\n  StringASTNode,\n} from 'vscode-json-languageservice';\nimport { TextDocument } from 'vscode-languageserver-textdocument';\nimport { Hover, HoverParams } from 'vscode-languageserver';\nimport {\n  getJsonLanguageService,\n  isPropertyNode,\n  isStringNode,\n} from '@nx-console/language-server/utils';\n\nexport async function getHover(\n  hoverParams: HoverParams,\n  jsonAst: JSONDocument,\n  document: TextDocument\n): Promise<Hover | null | undefined> {\n  const hover = await getJsonLanguageService()?.doHover(\n    document,\n    hoverParams.position,\n    jsonAst\n  );\n\n  if (!hover) {\n    return;\n  }\n\n  const offset = document.offsetAt(hoverParams.position);\n  const node = jsonAst.getNodeFromOffset(offset);\n\n  if (!node) {\n    return hover;\n  }\n\n  if (isExecutorStringNode(node)) {\n    hover.contents = {\n      kind: 'markdown',\n      value: `[View executor documentation on nx.dev](${constructExecutorUrl(\n        node.value\n      )})`,\n    };\n  }\n\n  return hover;\n}\n\nfunction isExecutorStringNode(node: ASTNode): node is StringASTNode {\n  return (\n    isStringNode(node) &&\n    isPropertyNode(node.parent) &&\n    node.parent.keyNode.value === 'executor' &&\n    (RegExp(/@nx|@nrwl\\/\\w+:\\w+/).test(node.value) ||\n      RegExp(/nx:\\w+/).test(node.value))\n  );\n}\n\nfunction constructExecutorUrl(executor: string): string {\n  const [packageName, executorName] = executor\n    .replace(/@nx|@nrwl/, '')\n    .split(':');\n  return `https://nx.dev/packages/${packageName}/executors/${executorName}`;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode-languageserver/node\");","import {\n  NotificationType,\n  RequestType,\n  ResponseError,\n} from 'vscode-languageserver/node';\nimport { NxWorkspace } from '@nx-console/shared/types';\nimport {\n  CollectionInfo,\n  Option,\n  TaskExecutionSchema,\n} from '@nx-console/shared/schema';\nimport type { ProjectConfiguration } from 'nx/src/devkit-exports';\nimport { SemVer } from 'semver';\n\nexport const NxChangeWorkspace: NotificationType<string> = new NotificationType(\n  'nx/changeWorkspace'\n);\n\nexport const NxWorkspaceRefreshNotification: NotificationType<void> =\n  new NotificationType('nx/refreshWorkspace');\n\nexport const NxWorkspaceRequest: RequestType<\n  { reset: boolean },\n  NxWorkspace,\n  unknown\n> = new RequestType('nx/workspace');\n\nexport type NxGeneratorsRequestOptions = {\n  includeHidden: boolean;\n  includeNgAdd: boolean;\n};\n\nexport const NxGeneratorsRequest: RequestType<\n  {\n    options?: NxGeneratorsRequestOptions;\n  },\n  CollectionInfo[],\n  unknown\n> = new RequestType('nx/generators');\n\nexport type NxGeneratorOptionsRequestOptions = {\n  collection: string;\n  name: string;\n  path: string;\n};\n\nexport const NxGeneratorOptionsRequest: RequestType<\n  { options: NxGeneratorOptionsRequestOptions },\n  Option[],\n  unknown\n> = new RequestType('nx/generatorOptions');\n\nexport const NxProjectByPathRequest: RequestType<\n  { projectPath: string },\n  ProjectConfiguration | null,\n  unknown\n> = new RequestType('nx/projectByPath');\n\nexport const NxGeneratorContextFromPathRequest: RequestType<\n  {\n    generator?: TaskExecutionSchema;\n    path: string;\n  },\n  | {\n      path?: string;\n      directory?: string;\n      project?: string;\n      projectName?: string;\n    }\n  | undefined,\n  unknown\n> = new RequestType('nx/generatorContextFromPath');\n\nexport const NxVersionRequest: RequestType<undefined, SemVer, unknown> =\n  new RequestType('nx/version');\n\nexport const NxProjectGraphOutputRequest: RequestType<\n  undefined,\n  {\n    directory: string;\n    relativePath: string;\n    fullPath: string;\n  },\n  unknown\n> = new RequestType('nx/projectGraphOutput');\n\nexport const NxCreateProjectGraphRequest: RequestType<\n  undefined,\n  string | undefined,\n  unknown\n> = new RequestType('nx/createProjectGraph');\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"request-light\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","import {\n  xhr,\n  XHRResponse,\n  configure as configureHttpRequests,\n  getErrorStatusDescription,\n} from 'request-light';\nimport { URI } from 'vscode-uri';\nimport * as fs from 'fs';\nimport { Thenable } from 'vscode-json-languageservice';\n\nexport interface RequestService {\n  getContent(uri: string): Promise<string>;\n}\n\nfunction getHTTPRequestService(): RequestService {\n  return {\n    getContent(uri: string, _encoding?: string) {\n      const headers = { 'Accept-Encoding': 'gzip, deflate' };\n      return xhr({ url: uri, followRedirects: 5, headers }).then(\n        (response) => {\n          return response.responseText;\n        },\n        (error: XHRResponse) => {\n          return Promise.reject(\n            error.responseText ||\n              getErrorStatusDescription(error.status) ||\n              error.toString()\n          );\n        }\n      );\n    },\n  };\n}\n\nfunction getFileRequestService(): RequestService {\n  return {\n    getContent(location: string, encoding?: BufferEncoding) {\n      return new Promise((c, e) => {\n        const uri = URI.parse(location);\n        fs.readFile(uri.fsPath, encoding, (err, buf) => {\n          if (err) {\n            return e(err);\n          }\n          c(buf.toString());\n        });\n      });\n    },\n  };\n}\n\nexport function getSchemaRequestService(\n  handledSchemas: string[] = ['https', 'http', 'file']\n) {\n  const builtInHandlers: { [protocol: string]: RequestService | undefined } =\n    {};\n  for (const protocol of handledSchemas) {\n    if (protocol === 'file') {\n      builtInHandlers[protocol] = getFileRequestService();\n    } else if (protocol === 'http' || protocol === 'https') {\n      builtInHandlers[protocol] = getHTTPRequestService();\n    }\n  }\n  return (uri: string): Thenable<string> => {\n    const protocol = uri.substr(0, uri.indexOf(':'));\n\n    const builtInHandler = builtInHandlers[protocol];\n    if (builtInHandler) {\n      return builtInHandler.getContent(uri);\n    }\n    return Promise.reject('Unable to retrieve schema');\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@parcel/watcher\");","import { lspLogger } from '@nx-console/language-server/utils';\nimport * as watcher from '@parcel/watcher';\nimport { platform } from 'os';\nimport { join } from 'path';\n\nexport async function languageServerWatcher(\n  workspacePath: string,\n  callback: () => unknown\n): Promise<() => void> {\n  const subscription = await watcher.subscribe(\n    workspacePath,\n    (err, events) => {\n      if (err) {\n        lspLogger.log('Error watching files: ' + err.toString());\n      } else if (\n        events.some(\n          (e) =>\n            e.path.endsWith('project.json') ||\n            e.path.endsWith('package.json') ||\n            e.path.endsWith('nx.json') ||\n            e.path.endsWith('workspace.json')\n        )\n      ) {\n        lspLogger.log('Project configuration changed');\n        debounce(callback, 200)();\n      }\n    },\n    watcherOptions(workspacePath)\n  );\n\n  return () => {\n    lspLogger.log('Unregistering file watcher');\n    subscription.unsubscribe();\n  };\n}\n\nfunction watcherOptions(workspacePath: string): watcher.Options | undefined {\n  const options: watcher.Options = {\n    ignore: [join(workspacePath, 'node_modules')],\n  };\n\n  if (platform() === 'win32') {\n    options.backend = 'windows';\n  }\n\n  return options;\n}\n\nfunction debounce(callback: () => any, wait: number) {\n  let timerId: NodeJS.Timeout;\n  return () => {\n    clearTimeout(timerId);\n    timerId = setTimeout(() => {\n      callback();\n    }, wait);\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.symbol.description.js\");","import { readdirSync, statSync } from 'fs';\nimport * as path from 'path';\n\nexport function listFiles(dirName: string): string[] {\n  // TODO use .gitignore to skip files\n  if (dirName.indexOf('node_modules') > -1) return [];\n  if (dirName.indexOf('dist') > -1) return [];\n\n  const res = [dirName];\n  // the try-catch here is intentional. It's only used in auto-completion.\n  // If it doesn't work, we don't want the process to exit\n  try {\n    readdirSync(dirName).forEach((c) => {\n      const child = path.join(dirName, c);\n      try {\n        if (!statSync(child).isDirectory()) {\n          res.push(child);\n        } else if (statSync(child).isDirectory()) {\n          res.push(...listFiles(child));\n        }\n      } catch {\n        // noop\n      }\n    });\n  } catch {\n    // noop\n  }\n  return res;\n}\n","import type { ProjectsConfigurations } from 'nx/src/devkit-exports';\nimport type { Schema } from 'nx/src/utils/params';\n\nexport enum OptionType {\n  Any = 'any',\n  Array = 'array',\n  Boolean = 'boolean',\n  Number = 'number',\n  String = 'string',\n}\n\nexport type OptionPropertyDescription = Schema['properties'][number];\n\nexport type CliOption = {\n  name: string;\n  originalName?: string;\n  positional?: number;\n  alias?: string;\n  hidden?: boolean;\n  deprecated?: boolean | string;\n} & OptionPropertyDescription;\n\nexport interface Option extends CliOption {\n  tooltip?: string;\n  itemTooltips?: ItemTooltips;\n  items?: string[] | ItemsWithEnum;\n  aliases: string[];\n  isRequired: boolean;\n  'x-dropdown'?: 'projects';\n  'x-priority'?: 'important' | 'internal';\n}\n\nexport interface ItemTooltips {\n  [itemValue: string]: string;\n}\n\nexport interface ItemsWithEnum {\n  enum: string[];\n  type: OptionType;\n}\n\nexport type XPrompt = string | LongFormXPrompt;\nexport interface LongFormXPrompt {\n  message: string;\n  type: 'confirmation' | 'input' | 'list' | string;\n  multiselect?: boolean;\n  items?: (string | OptionItemLabelValue)[];\n}\n\nexport interface OptionItemLabelValue {\n  label: string;\n  value: string;\n}\n\nexport interface TaskExecutionMessage {\n  command: string;\n  positional: string;\n  flags: string[];\n}\n\nexport interface TaskExecutionSchema {\n  name: string;\n  command: string;\n  collection?: string;\n  positional: string;\n  builder?: string;\n  description: string;\n  configurations?: TargetConfiguration[];\n  options: Option[];\n  contextValues?: {\n    path?: string;\n    directory?: string;\n    project?: string;\n    projectName?: string;\n  };\n}\n\nexport interface CollectionInfo {\n  name: string;\n  path: string;\n  type: 'executor' | 'generator';\n  data?: Generator;\n}\n\nexport enum GeneratorType {\n  Application = 'application',\n  Library = 'library',\n  Other = 'other',\n}\n\nexport interface Generator {\n  collection: string;\n  name: string;\n  description: string;\n  options?: Option[];\n  type: GeneratorType;\n  aliases: string[];\n}\n\nexport interface DefaultValue {\n  name: string;\n  defaultValue: string | undefined;\n}\n\nexport interface TargetConfiguration {\n  name: string;\n  defaultValues: DefaultValue[];\n}\n\nexport interface Targets {\n  name: string;\n  project: string;\n  builder: string | undefined;\n  description: string;\n  configurations: TargetConfiguration[];\n  options: CliOption[];\n}\n\nexport const WORKSPACE_GENERATOR_NAME_REGEX =\n  /^workspace-(schematic|generator):(.+)/;\n\nexport type WorkspaceProjects = ProjectsConfigurations['projects'];\n\nexport interface Logger {\n  log(message: string): void;\n}\n","import { TaskExecutionMessage, TaskExecutionSchema } from './schema';\n\nexport interface GlobalConfigurationData {\n  enableTaskExecutionDryRunOnChange: boolean;\n}\n\n// Task execution output messages\nexport type TaskExecutionOutputMessage =\n  | TaskExecutionFormInitOutputMessage\n  | TaskExecutionRunCommandOutputMessage;\n\nexport enum TaskExecutionOutputMessageType {\n  TaskExecutionFormInit = 'output-init',\n  RunCommand = 'run-command',\n}\n\nexport class TaskExecutionRunCommandOutputMessage {\n  readonly payloadType = TaskExecutionOutputMessageType.RunCommand;\n\n  constructor(public readonly payload: TaskExecutionMessage) {}\n}\n\nexport class TaskExecutionFormInitOutputMessage {\n  readonly payloadType = TaskExecutionOutputMessageType.TaskExecutionFormInit;\n}\n\n// Task execution input messages\nexport type TaskExecutionInputMessage =\n  | TaskExecutionSchemaInputMessage\n  | TaskExecutionGlobalConfigurationInputMessage\n  | TaskExecutionSetStylesMessage;\n\nexport enum TaskExecutionInputMessageType {\n  SetTaskExecutionSchema = 'generator',\n  SetGlobalConfiguration = 'config',\n  SetStyles = 'style',\n}\n\nexport class TaskExecutionSchemaInputMessage {\n  readonly payloadType = TaskExecutionInputMessageType.SetTaskExecutionSchema;\n\n  constructor(public readonly payload: TaskExecutionSchema) {}\n}\n\nexport class TaskExecutionGlobalConfigurationInputMessage {\n  readonly payloadType = TaskExecutionInputMessageType.SetGlobalConfiguration;\n\n  constructor(public readonly payload: GlobalConfigurationData) {}\n}\n\nexport class TaskExecutionSetStylesMessage {\n  readonly payloadType = TaskExecutionInputMessageType.SetStyles;\n\n  constructor(\n    public readonly payload: {\n      backgroundColor: string;\n      highlightTextColor: string;\n      secondaryTextColor: string;\n      fieldBackground: string;\n      fontFamily: string;\n      fontSize: string;\n    }\n  ) {}\n}\n","import { Option } from './schema';\n\nexport function isProjectOption(option: Option) {\n  return (\n    option.name === 'project' ||\n    option.name === 'projectName' ||\n    option.$default?.$source === 'projectName' ||\n    option['x-dropdown'] === 'projects'\n  );\n}\n","import {\n  CliOption,\n  ItemsWithEnum,\n  ItemTooltips,\n  LongFormXPrompt,\n  Option,\n  OptionItemLabelValue,\n  OptionPropertyDescription,\n  XPrompt,\n} from './schema';\nimport type { Schema } from 'nx/src/utils/params';\n\nexport interface GeneratorDefaults {\n  [name: string]: string;\n}\n\nexport async function normalizeSchema(\n  s: Schema,\n  projectDefaults?: GeneratorDefaults\n): Promise<Option[]> {\n  const options = schemaToOptions(s);\n  const requiredFields = new Set(s.required || []);\n\n  const nxOptions = options.map((option) => {\n    const xPrompt: XPrompt | undefined = option['x-prompt'];\n    const workspaceDefault =\n      projectDefaults?.[option.originalName ?? option.name];\n    const $default = option.$default;\n\n    const nxOption: Option = {\n      ...option,\n      isRequired: isFieldRequired(requiredFields, option, xPrompt, $default),\n      aliases: option.alias ? [option.alias] : [],\n      ...(workspaceDefault !== undefined && { default: workspaceDefault }),\n      ...($default && { $default }),\n      ...(option.enum && { items: option.enum.map((item) => item.toString()) }),\n      // Strongly suspect items does not belong in the Option schema.\n      //  Angular Option doesn't have the items property outside of x-prompt,\n      //  but items is used in @schematics/angular - guard\n      ...getItems(option),\n    };\n\n    if (xPrompt) {\n      nxOption.tooltip = isLongFormXPrompt(xPrompt) ? xPrompt.message : xPrompt;\n      nxOption.itemTooltips = getEnumTooltips(xPrompt);\n      if (isLongFormXPrompt(xPrompt) && !nxOption.items) {\n        const items = (xPrompt.items || []).map((item) =>\n          isOptionItemLabelValue(item) ? item.value : item\n        );\n        if (items.length > 0) {\n          nxOption.items = items;\n        }\n      }\n    }\n\n    return nxOption;\n  });\n\n  // since some folks are using Nx Console with older versions,\n  // we need to make sure their options are sorted like before\n  const optionComparator = nxOptions.some(\n    (option) => option['x-priority'] !== undefined\n  )\n    ? compareOptions\n    : legacyCompareOptions;\n\n  return nxOptions.sort(optionComparator);\n}\n\n/**\n * sorts options in the following order\n * - required\n * - x-priority: important\n * - everything else\n * - x-priority: internal\n * - deprecated\n * if two options are equal, they are sorted by whether they are positional args and name\n */\nfunction compareOptions(a: Option, b: Option): number {\n  function getPrio(opt: Option): number {\n    if (opt.isRequired) {\n      return 0;\n    }\n    if (opt['x-priority'] === 'important') {\n      return 1;\n    }\n    if (opt['x-deprecated']) {\n      return 4;\n    }\n    if (opt['x-priority'] === 'internal') {\n      return 3;\n    }\n    return 2;\n  }\n\n  const aPrio = getPrio(a);\n  const bPrio = getPrio(b);\n  if (aPrio === bPrio) {\n    if (typeof a.positional === 'number' && typeof b.positional === 'number') {\n      return a.positional - b.positional;\n    }\n    if (typeof a.positional === 'number') {\n      return -1;\n    } else if (typeof b.positional === 'number') {\n      return 1;\n    }\n    return a.name.localeCompare(b.name);\n  }\n  return aPrio - bPrio;\n}\n\nfunction legacyCompareOptions(a: Option, b: Option): number {\n  const IMPORTANT_FIELD_NAMES = [\n    'name',\n    'project',\n    'module',\n    'watch',\n    'style',\n    'directory',\n    'port',\n  ];\n  const IMPORTANT_FIELDS_SET = new Set(IMPORTANT_FIELD_NAMES);\n  if (typeof a.positional === 'number' && typeof b.positional === 'number') {\n    return a.positional - b.positional;\n  }\n\n  if (typeof a.positional === 'number') {\n    return -1;\n  } else if (typeof b.positional === 'number') {\n    return 1;\n  } else if (a.isRequired) {\n    if (b.isRequired) {\n      return a.name.localeCompare(b.name);\n    }\n    return -1;\n  } else if (b.isRequired) {\n    return 1;\n  } else if (IMPORTANT_FIELDS_SET.has(a.name)) {\n    if (IMPORTANT_FIELDS_SET.has(b.name)) {\n      return (\n        IMPORTANT_FIELD_NAMES.indexOf(a.name) -\n        IMPORTANT_FIELD_NAMES.indexOf(b.name)\n      );\n    }\n    return -1;\n  } else if (IMPORTANT_FIELDS_SET.has(b.name)) {\n    return 1;\n  } else {\n    return a.name.localeCompare(b.name);\n  }\n}\n\nfunction isFieldRequired(\n  requiredFields: Set<string>,\n  nxOption: CliOption,\n  xPrompt: XPrompt | undefined,\n  $default: any\n): boolean {\n  // checks schema.json requiredFields and xPrompt for required\n  return (\n    requiredFields.has(nxOption.name) ||\n    // makes xPrompt fields required so nx command can run with --no-interactive\n    // - except properties with a default (also falsey, empty, null)\n    // - except properties with a $default $source\n    // - except boolean properties (should also have default of `true`)\n    (!!xPrompt && !nxOption.default && !$default && nxOption.type !== 'boolean')\n  );\n}\n\nfunction getItems(option: CliOption): { items: string[] } | undefined {\n  return (\n    option.items && {\n      items:\n        (option.items as ItemsWithEnum).enum ||\n        ((option.items as string[]).length && option.items),\n    }\n  );\n}\n\nfunction isLongFormXPrompt(xPrompt: XPrompt): xPrompt is LongFormXPrompt {\n  return (xPrompt as Partial<LongFormXPrompt>).message !== undefined;\n}\n\nfunction getEnumTooltips(xPrompt: XPrompt): ItemTooltips {\n  const enumTooltips: ItemTooltips = {};\n  if (!!xPrompt && isLongFormXPrompt(xPrompt)) {\n    (xPrompt.items || []).forEach((item) => {\n      if (isOptionItemLabelValue(item) && !!item.label) {\n        enumTooltips[item.value] = item.label;\n      }\n    });\n  }\n  return enumTooltips;\n}\n\nfunction isOptionItemLabelValue(\n  item: string | OptionItemLabelValue\n): item is OptionItemLabelValue {\n  return (\n    (item as Partial<OptionItemLabelValue>).value !== undefined ||\n    (item as Partial<OptionItemLabelValue>).label !== undefined\n  );\n}\n\nfunction schemaToOptions(schema: Schema): CliOption[] {\n  return Object.keys(schema.properties || {}).reduce<CliOption[]>(\n    (cliOptions, option) => {\n      const currentProperty = schema.properties[option];\n      const $default = currentProperty.$default;\n      const $defaultIndex =\n        $default?.['$source'] === 'argv' ? $default['index'] : undefined;\n      const positional: number | undefined =\n        typeof $defaultIndex === 'number' ? $defaultIndex : undefined;\n\n      const visible = isPropertyVisible(option, currentProperty);\n      if (!visible) {\n        return cliOptions;\n      }\n      cliOptions.push({\n        name: option,\n        originalName: option,\n        positional,\n        ...currentProperty,\n      });\n      return cliOptions;\n    },\n    []\n  );\n}\n\nfunction isPropertyVisible(\n  option: string,\n  property: OptionPropertyDescription\n): boolean {\n  const ALWAYS_VISIBLE_OPTIONS = ['path'];\n\n  if (ALWAYS_VISIBLE_OPTIONS.includes(option)) {\n    return true;\n  }\n\n  if ('hidden' in property) {\n    return !(property as any)['hidden'];\n  }\n\n  return property.visible ?? true;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.flat.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"core-js/modules/es.array.unscopables.flat.js\");","import {\n  workspaceDependencies,\n  workspaceDependencyPath,\n  packageDetails,\n} from '@nx-console/shared/npm';\nimport {\n  CollectionInfo,\n  Generator,\n  GeneratorType,\n} from '@nx-console/shared/schema';\nimport { platform } from 'os';\nimport { dirname, resolve } from 'path';\nimport {\n  clearJsonCache,\n  readAndCacheJsonFile,\n} from '@nx-console/shared/file-system';\nimport { nxWorkspace } from './workspace';\n\nexport type ReadCollectionsOptions = {\n  clearPackageJsonCache?: boolean;\n  includeHidden?: boolean;\n  includeNgAdd?: boolean;\n};\n\nexport async function readCollections(\n  workspacePath: string,\n  options: ReadCollectionsOptions\n): Promise<CollectionInfo[]> {\n  if (options?.clearPackageJsonCache) {\n    clearJsonCache('package.json', workspacePath);\n  }\n\n  const {\n    workspace: { projects },\n    nxVersion,\n  } = await nxWorkspace(workspacePath);\n\n  const packages = await workspaceDependencies(\n    workspacePath,\n    nxVersion,\n    projects\n  );\n\n  const collections = await Promise.all(\n    packages.map(async (p) => {\n      return await packageDetails(p);\n    })\n  );\n\n  const allCollections = (\n    await Promise.all(\n      collections.map((c) => readCollection(workspacePath, c, options))\n    )\n  ).flat();\n\n  /**\n   * Since we gather all collections, and collections listed in `extends`, we need to dedupe collections here if workspaces have that extended collection in their own package.json\n   */\n  const dedupedCollections = new Map<string, CollectionInfo>();\n  for (const singleCollection of allCollections) {\n    if (!singleCollection) {\n      continue;\n    }\n\n    if (\n      !dedupedCollections.has(\n        collectionNameWithType(singleCollection.name, singleCollection.type)\n      )\n    ) {\n      dedupedCollections.set(\n        collectionNameWithType(singleCollection.name, singleCollection.type),\n        singleCollection\n      );\n    }\n  }\n\n  return Array.from(dedupedCollections.values());\n}\n\nasync function readCollection(\n  workspacePath: string,\n  {\n    packagePath,\n    packageName,\n    packageJson: json,\n  }: {\n    packagePath: string;\n    packageName: string;\n    packageJson: any;\n  },\n  options: ReadCollectionsOptions\n): Promise<CollectionInfo[] | null> {\n  try {\n    const [executorCollections, generatorCollections] = await Promise.all([\n      readAndCacheJsonFile(json.executors || json.builders, packagePath),\n      readAndCacheJsonFile(json.generators || json.schematics, packagePath),\n    ]);\n\n    return getCollectionInfo(\n      workspacePath,\n      packageName,\n      packagePath,\n      executorCollections,\n      generatorCollections,\n      options\n    );\n  } catch (e) {\n    return null;\n  }\n}\n\nexport async function getCollectionInfo(\n  workspacePath: string,\n  collectionName: string,\n  collectionPath: string,\n  executorCollection: { path: string; json: any },\n  generatorCollection: { path: string; json: any },\n  options: ReadCollectionsOptions\n): Promise<CollectionInfo[]> {\n  const collectionMap: Map<string, CollectionInfo> = new Map();\n\n  const buildCollectionInfo = (\n    name: string,\n    value: any,\n    type: 'executor' | 'generator',\n    schemaPath: string\n  ): CollectionInfo => {\n    let path = resolve(collectionPath, dirname(schemaPath), value.schema);\n\n    if (platform() === 'win32') {\n      path = `file:///${path.replace(/\\\\/g, '/')}`;\n    }\n\n    return {\n      name: `${collectionName}:${name}`,\n      type,\n      path,\n    };\n  };\n\n  const executors = {\n    ...executorCollection.json.executors,\n    ...executorCollection.json.builders,\n  };\n  for (const [key, schema] of Object.entries<any>(executors)) {\n    if (!canUse(key, schema, options.includeHidden, options.includeNgAdd)) {\n      continue;\n    }\n    const collectionInfo = buildCollectionInfo(\n      key,\n      schema,\n      'executor',\n      executorCollection.path\n    );\n    if (\n      collectionMap.has(collectionNameWithType(collectionInfo.name, 'executor'))\n    ) {\n      continue;\n    }\n    collectionMap.set(\n      collectionNameWithType(collectionInfo.name, 'executor'),\n      collectionInfo\n    );\n  }\n\n  const generators = {\n    ...generatorCollection.json.generators,\n    ...generatorCollection.json.schematics,\n  };\n  for (const [key, schema] of Object.entries<any>(generators)) {\n    if (!canUse(key, schema, options.includeHidden, options.includeNgAdd)) {\n      continue;\n    }\n\n    try {\n      const collectionInfo = buildCollectionInfo(\n        key,\n        schema,\n        'generator',\n        generatorCollection.path\n      );\n      collectionInfo.data = readCollectionGenerator(\n        collectionName,\n        key,\n        schema\n      );\n      if (\n        collectionMap.has(\n          collectionNameWithType(collectionInfo.name, 'generator')\n        )\n      ) {\n        continue;\n      }\n      collectionMap.set(\n        collectionNameWithType(collectionInfo.name, 'generator'),\n        collectionInfo\n      );\n    } catch (e) {\n      // noop - generator is invalid\n    }\n  }\n\n  if (\n    generatorCollection.json.extends &&\n    Array.isArray(generatorCollection.json.extends)\n  ) {\n    const extendedSchema = generatorCollection.json.extends as string[];\n    const extendedCollections = (\n      await Promise.all(\n        extendedSchema\n          .filter(\n            (extended) =>\n              extended !== '@nx/workspace' && extended !== '@nrwl/workspace'\n          )\n          .map(async (extended: string) => {\n            const dependencyPath = await workspaceDependencyPath(\n              workspacePath,\n              extended\n            );\n\n            if (!dependencyPath) {\n              return null;\n            }\n\n            return readCollection(\n              workspacePath,\n              await packageDetails(dependencyPath),\n              options\n            );\n          })\n      )\n    )\n      .flat()\n      .filter((c): c is CollectionInfo => Boolean(c));\n\n    for (const collection of extendedCollections) {\n      if (collectionMap.has(collection.name)) {\n        continue;\n      }\n\n      collectionMap.set(collection.name, collection);\n    }\n  }\n\n  return Array.from(collectionMap.values());\n}\n\nfunction readCollectionGenerator(\n  collectionName: string,\n  collectionSchemaName: string,\n  collectionJson: any\n): Generator | undefined {\n  try {\n    let generatorType: GeneratorType;\n    switch (collectionJson['x-type']) {\n      case 'application':\n        generatorType = GeneratorType.Application;\n        break;\n      case 'library':\n        generatorType = GeneratorType.Library;\n        break;\n      default:\n        generatorType = GeneratorType.Other;\n        break;\n    }\n    return {\n      name: collectionSchemaName,\n      collection: collectionName,\n      description: collectionJson.description || '',\n      aliases: collectionJson.aliases ?? [],\n      type: generatorType,\n    };\n  } catch (e) {\n    console.error(e);\n    console.error(\n      `Invalid package.json for schematic ${collectionName}:${collectionSchemaName}`\n    );\n  }\n}\n\n/**\n * Checks to see if the collection is usable within Nx Console.\n * @param name\n * @param s\n * @returns\n */\nfunction canUse(\n  name: string,\n  s: {\n    hidden: boolean;\n    private: boolean;\n    schema: string;\n    extends: boolean;\n    'x-deprecated'?: string;\n  },\n  includeHiddenCollections = false,\n  includeNgAddCollection = false\n): boolean {\n  return (\n    (!s.hidden || includeHiddenCollections) &&\n    !s.private &&\n    !s.extends &&\n    !s['x-deprecated'] &&\n    (name !== 'ng-add' || includeNgAddCollection)\n  );\n}\n\nfunction collectionNameWithType(name: string, type: 'generator' | 'executor') {\n  return `${name}-${type}`;\n}\n","import { NxGeneratorsRequestOptions } from '@nx-console/language-server/types';\nimport {\n  directoryExists,\n  fileExists,\n  listFiles,\n  readAndCacheJsonFile,\n} from '@nx-console/shared/file-system';\nimport { CollectionInfo, GeneratorType } from '@nx-console/shared/schema';\nimport { normalizeSchema } from '@nx-console/shared/schema/normalize';\nimport { basename, join } from 'path';\nimport { getCollectionInfo, readCollections } from './read-collections';\n\nexport async function getGenerators(\n  workspacePath: string,\n  options: NxGeneratorsRequestOptions = {\n    includeHidden: false,\n    includeNgAdd: false,\n  }\n): Promise<CollectionInfo[]> {\n  const basedir = workspacePath;\n  const collections = await readCollections(workspacePath, {\n    clearPackageJsonCache: false,\n    includeHidden: options.includeHidden,\n    includeNgAdd: options.includeNgAdd,\n  });\n  let generatorCollections = collections.filter(\n    (collection) => collection.type === 'generator'\n  );\n\n  generatorCollections = [\n    ...generatorCollections,\n    ...(await checkAndReadWorkspaceGenerators(basedir, 'schematics', options)),\n    ...(await checkAndReadWorkspaceGenerators(basedir, 'generators', options)),\n  ];\n  return generatorCollections.filter(\n    (collection): collection is CollectionInfo => !!collection.data\n  );\n}\n\nasync function checkAndReadWorkspaceGenerators(\n  basedir: string,\n  workspaceGeneratorType: 'generators' | 'schematics',\n  options: NxGeneratorsRequestOptions\n) {\n  const workspaceGeneratorsPath = join('tools', workspaceGeneratorType);\n  if (await directoryExists(join(basedir, workspaceGeneratorsPath))) {\n    const collection = await readWorkspaceGeneratorsCollection(\n      basedir,\n      workspaceGeneratorsPath,\n      workspaceGeneratorType,\n      options\n    );\n    return collection;\n  }\n  return Promise.resolve([]);\n}\n\nasync function readWorkspaceGeneratorsCollection(\n  basedir: string,\n  workspaceGeneratorsPath: string,\n  workspaceGeneratorType: 'generators' | 'schematics',\n  options: NxGeneratorsRequestOptions\n): Promise<CollectionInfo[]> {\n  const collectionDir = join(basedir, workspaceGeneratorsPath);\n  const collectionName = `workspace-${\n    workspaceGeneratorType === 'generators' ? 'generator' : 'schematic'\n  }`;\n  const collectionPath = join(collectionDir, 'collection.json');\n  if (await fileExists(collectionPath)) {\n    const collection = await readAndCacheJsonFile(\n      `${collectionDir}/collection.json`\n    );\n\n    return getCollectionInfo(\n      basedir,\n      collectionName,\n      collectionPath,\n      {\n        path: collectionPath,\n        json: {},\n      },\n      collection.json,\n      options\n    );\n  } else {\n    return await Promise.all(\n      listFiles(collectionDir)\n        .filter((f) => basename(f) === 'schema.json')\n        .map(async (schemaJsonPath) => {\n          const schemaJson = await readAndCacheJsonFile(schemaJsonPath, '');\n          const name = schemaJson.json.id || schemaJson.json.$id;\n          const type: GeneratorType =\n            schemaJson.json['x-type'] ?? GeneratorType.Other;\n          return {\n            name: collectionName,\n            type: 'generator',\n            path: schemaJsonPath,\n            data: {\n              name,\n              collection: collectionName,\n              options: await normalizeSchema(schemaJson.json),\n              description: schemaJson.json.description ?? '',\n              type,\n            },\n          } as CollectionInfo;\n        })\n    );\n  }\n}\n","import { readAndCacheJsonFile } from '@nx-console/shared/file-system';\nimport { Option } from '@nx-console/shared/schema';\nimport { normalizeSchema } from '@nx-console/shared/schema/normalize';\nimport { nxWorkspace } from './workspace';\n\nexport async function getGeneratorOptions(\n  workspacePath: string,\n  collectionName: string,\n  generatorName: string,\n  generatorPath: string\n): Promise<Option[]> {\n  const generatorSchema = await readAndCacheJsonFile(generatorPath);\n  const workspaceDefaults = await readWorkspaceJsonDefaults(workspacePath);\n  const defaults =\n    workspaceDefaults &&\n    workspaceDefaults[collectionName] &&\n    workspaceDefaults[collectionName][generatorName];\n  return await normalizeSchema(generatorSchema.json, defaults);\n}\n\nasync function readWorkspaceJsonDefaults(workspacePath: string): Promise<any> {\n  const { workspace } = await nxWorkspace(workspacePath);\n\n  let defaults = workspace.generators;\n\n  if (!defaults) {\n    try {\n      /**\n       * This could potentially fail if we're in an Angular CLI project without schematics being part of angular.json\n       * Default the default to {} on the catch\n       */\n      defaults = workspace.generators || {};\n    } catch (e) {\n      defaults = {};\n    }\n  }\n\n  const collectionDefaults = Object.keys(defaults).reduce(\n    (collectionDefaultsMap: any, key) => {\n      if (key.includes(':')) {\n        const [collectionName, generatorName] = key.split(':');\n        if (!collectionDefaultsMap[collectionName]) {\n          collectionDefaultsMap[collectionName] = {};\n        }\n        collectionDefaultsMap[collectionName][generatorName] = defaults?.[key];\n      } else {\n        const collectionName = key;\n        if (!collectionDefaultsMap[collectionName]) {\n          collectionDefaultsMap[collectionName] = {};\n        }\n        Object.keys(defaults?.[collectionName] ?? {}).forEach(\n          (generatorName) => {\n            collectionDefaultsMap[collectionName][generatorName] =\n              defaults?.[collectionName][generatorName];\n          }\n        );\n      }\n      return collectionDefaultsMap;\n    },\n    {}\n  );\n  return collectionDefaults;\n}\n","import type { ProjectConfiguration } from 'nx/src/devkit-exports';\nimport { directoryExists } from '@nx-console/shared/file-system';\nimport { isAbsolute, join, relative, sep } from 'path';\nimport { nxWorkspace } from './workspace';\n\nexport async function getProjectByPath(\n  selectedPath: string | undefined,\n  workspacePath: string\n): Promise<ProjectConfiguration | null> {\n  if (!selectedPath) {\n    return null;\n  }\n\n  const { workspace } = await nxWorkspace(workspacePath);\n\n  const relativeFilePath = relative(workspacePath, selectedPath);\n  const isDirectory = await directoryExists(selectedPath);\n\n  const projectEntries = Object.entries(workspace.projects);\n  let foundProject: ProjectConfiguration | null = null;\n\n  for (const [projectName, projectConfig] of projectEntries) {\n    const isChildOfRoot = isChildOrEqual(projectConfig.root, relativeFilePath);\n    const relativeRootConfig = projectConfig.sourceRoot\n      ? relative(workspacePath, projectConfig.sourceRoot)\n      : undefined;\n    const isChildOfRootConfig =\n      relativeRootConfig &&\n      isChildOrEqual(relativeRootConfig, relativeFilePath);\n\n    if (!projectConfig.files) {\n      foundProject = findByFilePath(\n        [projectName, projectConfig],\n        workspacePath,\n        selectedPath\n      );\n    } else if (isDirectory && (isChildOfRoot || isChildOfRootConfig)) {\n      foundProject = projectConfig;\n    } else if (\n      !isDirectory &&\n      projectConfig.files.some(({ file }) => file === relativeFilePath)\n    ) {\n      foundProject = projectConfig;\n    }\n\n    if (foundProject) {\n      break;\n    }\n  }\n\n  return foundProject;\n}\n\n/** This is only used for backwards compatibility  */\nfunction findByFilePath(\n  entry: [string, ProjectConfiguration] | undefined,\n  workspacePath: string,\n  selectedPath: string\n) {\n  if (!entry) {\n    return null;\n  }\n\n  let perfectMatchEntry: [string, ProjectConfiguration] | undefined;\n  let secondaryMatchEntry: [string, ProjectConfiguration] | undefined;\n\n  const [, projectConfiguration] = entry;\n  const fullProjectPath = join(\n    workspacePath,\n    // If root is empty, that means we're in an angular project with the old ng workspace setup. Otherwise use the sourceRoot\n    projectConfiguration.root || projectConfiguration.sourceRoot || ''\n  );\n  if (fullProjectPath === selectedPath) {\n    perfectMatchEntry = entry;\n  }\n\n  const relativePath = relative(fullProjectPath, selectedPath);\n  if (\n    relativePath &&\n    !relativePath.startsWith('..') &&\n    !isAbsolute(relativePath)\n  ) {\n    secondaryMatchEntry = entry;\n  }\n\n  entry = perfectMatchEntry ?? secondaryMatchEntry;\n\n  return entry ? { name: entry[0], ...entry[1] } : null;\n}\n\nfunction isChildOrEqual(parent: string, child: string) {\n  const p = parent.endsWith(sep) ? parent : parent + sep;\n  const c = child.endsWith(sep) ? child : child + sep;\n  return c.startsWith(p);\n}\n","import { cacheDir } from 'nx/src/devkit-exports';\nimport { join, relative, normalize } from 'path';\n\nexport function getProjectGraphOutput(workspacePath: string) {\n  const directory = join(cacheDir, 'nx-console-project-graph');\n  const fullPath = `${directory}/project-graph.html`;\n  return {\n    directory,\n    relativePath: `./${normalize(relative(workspacePath, fullPath))}`,\n    fullPath,\n  };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"child_process\");","import { Logger } from '@nx-console/shared/schema';\nimport { getNxExecutionCommand } from '@nx-console/shared/utils';\n\nimport { execSync } from 'child_process';\nimport { getProjectGraphOutput } from './get-project-graph-output';\nimport { nxWorkspace } from './workspace';\n\nexport async function createProjectGraph(\n  workspacePath: string,\n  logger: Logger = {\n    log(message) {\n      console.log(message);\n    },\n  }\n): Promise<string | undefined> {\n  const { isEncapsulatedNx } = await nxWorkspace(workspacePath);\n  const projectGraphOutput = getProjectGraphOutput(workspacePath);\n\n  return new Promise<string | undefined>((res, rej) => {\n    const command = getNxExecutionCommand({\n      cwd: workspacePath,\n      displayCommand: 'nx dep-graph --file ' + projectGraphOutput.relativePath,\n      encapsulatedNx: isEncapsulatedNx,\n      useNpx: true,\n    });\n\n    logger.log(`Generating graph with command: \\`${command}\\``);\n    try {\n      execSync(command, {\n        cwd: workspacePath,\n        windowsHide: true,\n        // Since this is going to be used within nxls, we need to make sure that stdio is set to ignore\n        // The lsp is set up to write to the host on stdio, so if we pollute the stdio with data that is not\n        // standard lsp, the connection will close because of malformed data.\n        stdio: 'ignore',\n      });\n\n      res(undefined);\n    } catch (e) {\n      const errorMessage = e.output[1].toString() || e.toString();\n      rej('Unable to create project graph: ' + errorMessage);\n    }\n  });\n}\n","import {\n  detectPackageManager,\n  getPackageManagerCommand,\n} from 'nx/src/devkit-exports';\nimport { platform } from 'os';\n\n/**\n * see `getShellExecutionForConfig` for a vscode-specific implementation of this\n */\nexport function getNxExecutionCommand(config: {\n  cwd: string;\n  displayCommand: string;\n  encapsulatedNx: boolean;\n  useNpx?: boolean;\n}): string {\n  let command = config.displayCommand;\n  if (config.encapsulatedNx) {\n    if (platform() == 'win32') {\n      command = command.replace(/^nx/, './nx.bat');\n    } else {\n      command = command.replace(/^nx/, './nx');\n    }\n  } else {\n    if (config.useNpx) {\n      command = `npx ${command}`;\n    } else {\n      const packageManager = detectPackageManager(config.cwd);\n      const packageManagerCommand = getPackageManagerCommand(packageManager);\n      command = `${packageManagerCommand.exec} ${command}`;\n    }\n  }\n\n  return command;\n}\n","import { getCompletionItems } from '@nx-console/language-server/capabilities/code-completion';\nimport { getDocumentLinks } from '@nx-console/language-server/capabilities/document-links';\nimport { getHover } from '@nx-console/language-server/capabilities/hover';\nimport {\n  NxChangeWorkspace,\n  NxCreateProjectGraphRequest,\n  NxGeneratorContextFromPathRequest,\n  NxGeneratorOptionsRequest,\n  NxGeneratorOptionsRequestOptions,\n  NxGeneratorsRequest,\n  NxGeneratorsRequestOptions,\n  NxProjectByPathRequest,\n  NxProjectGraphOutputRequest,\n  NxVersionRequest,\n  NxWorkspaceRefreshNotification,\n  NxWorkspaceRequest,\n} from '@nx-console/language-server/types';\nimport {\n  configureJsonLanguageService,\n  getJsonLanguageService,\n  getLanguageModelCache,\n  getSchemaRequestService,\n  lspLogger,\n  mergeArrays,\n  setLspLogger,\n} from '@nx-console/language-server/utils';\nimport { languageServerWatcher } from '@nx-console/language-server/watcher';\nimport {\n  getExecutors,\n  getGeneratorContextFromPath,\n  getGeneratorOptions,\n  getGenerators,\n  getProjectByPath,\n  getNxVersion,\n  nxWorkspace,\n  getProjectGraphOutput,\n  createProjectGraph,\n} from '@nx-console/language-server/workspace';\nimport {\n  getNxJsonSchema,\n  getPackageJsonSchema,\n  getProjectJsonSchema,\n  getWorkspaceJsonSchema,\n} from '@nx-console/shared/json-schema';\nimport { TaskExecutionSchema } from '@nx-console/shared/schema';\nimport { formatError } from '@nx-console/shared/utils';\nimport {\n  ClientCapabilities,\n  CompletionList,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport {\n  createConnection,\n  CreateFilesParams,\n  DeleteFilesParams,\n  FileOperationPatternKind,\n  InitializeResult,\n  ProposedFeatures,\n  ResponseError,\n  TextDocuments,\n  TextDocumentSyncKind,\n} from 'vscode-languageserver/node';\nimport { URI, Utils } from 'vscode-uri';\n\nprocess.on('unhandledRejection', (e: any) => {\n  connection.console.error(formatError(`Unhandled exception`, e));\n});\n\nprocess.on('uncaughtException', (e) => {\n  connection.console.error(formatError('Unhandled exception', e));\n});\n\nlet WORKING_PATH: string | undefined = undefined;\nlet CLIENT_CAPABILITIES: ClientCapabilities | undefined = undefined;\nlet unregisterFileWatcher: () => void = () => {\n  //noop\n};\n\nconst workspaceContext = {\n  resolveRelativePath: (relativePath: string, resource: string) => {\n    const base = resource.substring(0, resource.lastIndexOf('/') + 1);\n    return Utils.resolvePath(URI.parse(base), relativePath).toString();\n  },\n};\n\nconst connection = createConnection(ProposedFeatures.all);\n\n// Create a text document manager.\nconst documents = new TextDocuments(TextDocument);\n\n// Make the text document manager listen on the connection\n// for open, change and close text document events\ndocuments.listen(connection);\n\nconnection.onInitialize(async (params) => {\n  setLspLogger(connection);\n\n  const { workspacePath } = params.initializationOptions ?? {};\n  try {\n    WORKING_PATH =\n      workspacePath ||\n      params.workspaceFolders?.[0]?.uri ||\n      params.rootPath ||\n      URI.parse(params.rootUri ?? '').fsPath;\n\n    if (!WORKING_PATH) {\n      throw 'Unable to determine workspace path';\n    }\n\n    CLIENT_CAPABILITIES = params.capabilities;\n\n    configureSchemas(WORKING_PATH, CLIENT_CAPABILITIES);\n    unregisterFileWatcher = await languageServerWatcher(\n      WORKING_PATH,\n      async () => {\n        await reconfigure(WORKING_PATH!);\n        await connection.sendNotification(\n          NxWorkspaceRefreshNotification.method\n        );\n      }\n    );\n  } catch (e) {\n    lspLogger.log('Unable to get Nx info: ' + e.toString());\n  }\n\n  const result: InitializeResult = {\n    capabilities: {\n      textDocumentSync: TextDocumentSyncKind.Incremental,\n      completionProvider: {\n        resolveProvider: false,\n        triggerCharacters: ['\"', ':'],\n      },\n      hoverProvider: true,\n      documentLinkProvider: {\n        resolveProvider: false,\n        workDoneProgress: false,\n      },\n      workspace: {\n        fileOperations: {\n          didCreate: {\n            filters: [\n              {\n                pattern: {\n                  glob: '**/project.json',\n                  matches: FileOperationPatternKind.file,\n                },\n              },\n            ],\n          },\n          didDelete: {\n            filters: [\n              {\n                pattern: {\n                  glob: '**/project.json',\n                  matches: FileOperationPatternKind.file,\n                },\n              },\n            ],\n          },\n        },\n      },\n    },\n  };\n\n  return result;\n});\n\nconnection.onCompletion(async (completionParams) => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n\n  const changedDocument = documents.get(completionParams.textDocument.uri);\n  if (!changedDocument) {\n    return null;\n  }\n\n  const { jsonAst, document } = getJsonDocument(changedDocument);\n\n  const completionResults =\n    (await getJsonLanguageService()?.doComplete(\n      document,\n      completionParams.position,\n      jsonAst\n    )) ?? CompletionList.create([]);\n\n  const schemas = await getJsonLanguageService()?.getMatchingSchemas(\n    document,\n    jsonAst\n  );\n\n  if (!schemas) {\n    return completionResults;\n  }\n\n  const { nxVersion } = await nxWorkspace(WORKING_PATH, lspLogger);\n\n  const pathItems = await getCompletionItems(\n    WORKING_PATH,\n    nxVersion,\n    jsonAst,\n    document,\n    schemas,\n    completionParams.position\n  );\n  mergeArrays(completionResults.items, pathItems);\n\n  return completionResults;\n});\n\nconnection.onHover(async (hoverParams) => {\n  const hoverDocument = documents.get(hoverParams.textDocument.uri);\n\n  if (!hoverDocument) {\n    return null;\n  }\n\n  const { jsonAst, document } = getJsonDocument(hoverDocument);\n  return await getHover(hoverParams, jsonAst, document);\n});\n\nconnection.onDocumentLinks(async (params) => {\n  const linkDocument = documents.get(params.textDocument.uri);\n\n  if (!linkDocument) {\n    return null;\n  }\n\n  const { jsonAst, document } = getJsonDocument(linkDocument);\n\n  const schemas = await getJsonLanguageService()?.getMatchingSchemas(\n    document,\n    jsonAst\n  );\n\n  if (!schemas) {\n    return;\n  }\n\n  return getDocumentLinks(WORKING_PATH, jsonAst, document, schemas);\n});\n\nconst jsonDocumentMapper = getLanguageModelCache();\n\ndocuments.onDidClose((e) => {\n  jsonDocumentMapper.onDocumentRemoved(e.document);\n});\n\nconnection.onShutdown(() => {\n  unregisterFileWatcher();\n  jsonDocumentMapper.dispose();\n});\n\nconnection.onRequest(NxWorkspaceRequest, async ({ reset }) => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n\n  return nxWorkspace(WORKING_PATH, lspLogger, reset);\n});\n\nconnection.onRequest(\n  NxGeneratorsRequest,\n  async (args: { options?: NxGeneratorsRequestOptions }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    return getGenerators(WORKING_PATH, args.options);\n  }\n);\n\nconnection.onRequest(\n  NxGeneratorOptionsRequest,\n  async (args: { options: NxGeneratorOptionsRequestOptions }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    return getGeneratorOptions(\n      WORKING_PATH,\n      args.options.collection,\n      args.options.name,\n      args.options.path\n    );\n  }\n);\n\nconnection.onRequest(\n  NxProjectByPathRequest,\n  async (args: { projectPath: string }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getProjectByPath(args.projectPath, WORKING_PATH);\n  }\n);\n\nconnection.onRequest(\n  NxGeneratorContextFromPathRequest,\n  async (args: { generator?: TaskExecutionSchema; path: string }) => {\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1000,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n    return getGeneratorContextFromPath(args.generator, args.path, WORKING_PATH);\n  }\n);\n\nconnection.onRequest(NxVersionRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  return getNxVersion(WORKING_PATH);\n});\n\nconnection.onRequest(NxProjectGraphOutputRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  return getProjectGraphOutput(WORKING_PATH);\n});\n\nconnection.onRequest(NxCreateProjectGraphRequest, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1000, 'Unable to get Nx info: no workspace path');\n  }\n  try {\n    await createProjectGraph(WORKING_PATH, lspLogger);\n  } catch (e) {\n    return e;\n  }\n});\n\nconnection.onNotification(NxWorkspaceRefreshNotification, async () => {\n  if (!WORKING_PATH) {\n    return new ResponseError(1001, 'Unable to get Nx info: no workspace path');\n  }\n\n  await reconfigure(WORKING_PATH);\n});\n\nconnection.onNotification(\n  'workspace/didCreateFiles',\n  async (createdFiles: CreateFilesParams) => {\n    if (!createdFiles.files.some((f) => f.uri.endsWith('project.json'))) {\n      return;\n    }\n\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1001,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    await reconfigure(WORKING_PATH);\n  }\n);\n\nconnection.onNotification(\n  'workspace/didDeleteFiles',\n  async (deletedFiles: DeleteFilesParams) => {\n    if (!deletedFiles.files.some((f) => f.uri.endsWith('project.json'))) {\n      return;\n    }\n\n    if (!WORKING_PATH) {\n      return new ResponseError(\n        1001,\n        'Unable to get Nx info: no workspace path'\n      );\n    }\n\n    await reconfigure(WORKING_PATH);\n  }\n);\n\nconnection.onNotification(NxChangeWorkspace, async (workspacePath) => {\n  WORKING_PATH = workspacePath;\n  await reconfigure(WORKING_PATH);\n});\n\nasync function reconfigure(workingPath: string) {\n  await nxWorkspace(workingPath, lspLogger, true);\n  await configureSchemas(workingPath, CLIENT_CAPABILITIES);\n}\n\nasync function configureSchemas(\n  workingPath: string | undefined,\n  capabilities: ClientCapabilities | undefined\n) {\n  if (!workingPath) {\n    lspLogger.log('No workspace path provided');\n    return;\n  }\n\n  const { workspace, nxVersion } = await nxWorkspace(workingPath, lspLogger);\n  const collections = await getExecutors(workingPath);\n  const workspaceSchema = getWorkspaceJsonSchema(collections);\n  const projectSchema = getProjectJsonSchema(\n    collections,\n    workspace.targetDefaults,\n    nxVersion\n  );\n  const packageSchema = getPackageJsonSchema(nxVersion);\n\n  const nxSchema = getNxJsonSchema(collections, workspace.projects, nxVersion);\n\n  configureJsonLanguageService(\n    {\n      schemaRequestService: getSchemaRequestService(['file']),\n      workspaceContext,\n      contributions: [],\n      clientCapabilities: capabilities,\n    },\n    {\n      schemas: [\n        {\n          uri: 'nx://schemas/workspace',\n          fileMatch: ['**/workspace.json'],\n          schema: workspaceSchema,\n        },\n        {\n          uri: 'nx://schemas/project',\n          fileMatch: ['**/project.json'],\n          schema: projectSchema,\n        },\n        {\n          uri: 'nx://schemas/package',\n          fileMatch: ['**/package.json'],\n          schema: packageSchema,\n        },\n        {\n          uri: 'nx://schemas/nx',\n          fileMatch: ['**/nx.json'],\n          schema: nxSchema,\n        },\n      ],\n    }\n  );\n}\n\nfunction getJsonDocument(document: TextDocument) {\n  return jsonDocumentMapper.retrieve(document);\n}\n\nconnection.listen();\n","/**\n * Combines the second array with the first array, without having to loop or change the reference of the first array.\n * @param arr1\n * @param arr2\n */\nexport function mergeArrays(arr1: Array<unknown>, arr2: Array<unknown>) {\n  Array.prototype.push.apply(arr1, arr2);\n}\n","import { fileExists } from '@nx-console/shared/file-system';\nimport {\n  CompletionType,\n  hasCompletionType,\n  X_COMPLETION_TYPE,\n} from '@nx-console/shared/json-schema';\nimport {\n  findProjectRoot,\n  getDefaultCompletionType,\n  hasDefaultCompletionType,\n  isStringNode,\n} from '@nx-console/language-server/utils';\nimport { join } from 'path';\nimport {\n  DocumentLink,\n  JSONDocument,\n  MatchingSchema,\n  TextDocument,\n} from 'vscode-json-languageservice';\nimport { createRange } from './create-range';\nimport { targetLink } from './target-link';\n\nexport async function getDocumentLinks(\n  workingPath: string | undefined,\n  jsonAst: JSONDocument,\n  document: TextDocument,\n  schemas: MatchingSchema[]\n): Promise<DocumentLink[]> {\n  if (!workingPath) {\n    return [];\n  }\n\n  const links: DocumentLink[] = [];\n\n  if (!jsonAst.root) {\n    return [];\n  }\n\n  const projectRoot = findProjectRoot(jsonAst.root);\n  const projectRootPath = join(workingPath, projectRoot);\n\n  for (const { schema, node } of schemas) {\n    let linkType: CompletionType | undefined;\n    if (hasCompletionType(schema)) {\n      linkType = schema[X_COMPLETION_TYPE];\n    } else if (hasDefaultCompletionType(node)) {\n      linkType = getDefaultCompletionType(node)?.completionType;\n    }\n\n    if (!linkType) {\n      continue;\n    }\n\n    if (linkType === 'directory') {\n      continue;\n    }\n\n    const range = createRange(document, node);\n\n    switch (linkType) {\n      case 'file': {\n        if (!isStringNode(node)) {\n          continue;\n        }\n\n        const fullPath = join(workingPath, node.value);\n        if (!(await fileExists(fullPath))) {\n          continue;\n        }\n\n        if (node.value === projectRoot) {\n          links.push({\n            range,\n            target: projectRootPath,\n          });\n        } else {\n          links.push(DocumentLink.create(range, fullPath));\n        }\n        break;\n      }\n      case 'projectTarget': {\n        const link = await targetLink(workingPath, node);\n        if (link) {\n          links.push(DocumentLink.create(range, link));\n        }\n        break;\n      }\n      default:\n    }\n  }\n\n  return links;\n}\n","import { CollectionInfo } from '@nx-console/shared/schema';\nimport { readCollections } from './read-collections';\n\nexport type GetExecutorsOptions = {\n  includeHidden: boolean;\n  clearPackageJsonCache: boolean;\n};\n\nexport async function getExecutors(\n  workspacePath: string,\n  options: GetExecutorsOptions = {\n    includeHidden: false,\n    clearPackageJsonCache: false,\n  }\n): Promise<CollectionInfo[]> {\n  return (\n    await readCollections(workspacePath, {\n      clearPackageJsonCache: options.clearPackageJsonCache,\n      includeHidden: options.includeHidden,\n    })\n  ).filter((collection) => collection.type === 'executor');\n}\n","import { CollectionInfo } from '@nx-console/shared/schema';\nimport { JSONSchema } from 'vscode-json-languageservice';\nimport { createBuildersAndExecutorsSchema } from './create-builders-and-executors-schema';\n\nexport function getWorkspaceJsonSchema(collections: CollectionInfo[]) {\n  const [builders, executors] = createBuildersAndExecutorsSchema(collections);\n  const contents = createJsonSchema(builders, executors);\n  return contents;\n}\n\nfunction createJsonSchema(\n  builders: JSONSchema[],\n  executors: JSONSchema[]\n): JSONSchema {\n  return {\n    title: 'JSON schema for Nx workspaces',\n    id: 'https://nx.dev',\n    type: 'object',\n    properties: {\n      version: {\n        type: 'number',\n        enum: [1, 2],\n      },\n    },\n    allOf: [\n      {\n        if: {\n          properties: { version: { const: 1 } },\n          required: ['version'],\n        },\n        then: {\n          properties: {\n            projects: {\n              type: 'object',\n              additionalProperties: {\n                type: 'object',\n                properties: {\n                  architect: {\n                    description:\n                      'Configures all the targets which define what tasks you can run against the project',\n                    additionalProperties: {\n                      type: 'object',\n                      properties: {\n                        builder: {\n                          description:\n                            'The function that Nx will invoke when you run this architect',\n                          type: 'string',\n                        },\n                        options: {\n                          type: 'object',\n                        },\n                        configurations: {\n                          description:\n                            'provides extra sets of values that will be merged into the options map',\n                          additionalProperties: {\n                            type: 'object',\n                          },\n                        },\n                      },\n                      allOf: builders,\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      {\n        if: {\n          properties: { version: { const: 2 } },\n          required: ['version'],\n        },\n        then: {\n          properties: {\n            projects: {\n              type: 'object',\n              additionalProperties: {\n                oneOf: [\n                  {\n                    type: 'string',\n                  },\n                  {\n                    type: 'object',\n                    properties: {\n                      targets: {\n                        description:\n                          'Configures all the targets which define what tasks you can run against the project',\n                        additionalProperties: {\n                          type: 'object',\n                          properties: {\n                            executor: {\n                              description:\n                                'The function that Nx will invoke when you run this target',\n                              type: 'string',\n                            },\n                            options: {\n                              type: 'object',\n                            },\n                            configurations: {\n                              description:\n                                'provides extra sets of values that will be merged into the options map',\n                              additionalProperties: {\n                                type: 'object',\n                              },\n                            },\n                          },\n                          allOf: executors,\n                        },\n                      },\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        },\n      },\n    ],\n  };\n}\n","import {\n  TaskExecutionSchema,\n  isProjectOption,\n} from '@nx-console/shared/schema';\nimport { getProjectByPath } from './get-project-by-path';\nimport { nxWorkspace } from './workspace';\n\nexport async function getGeneratorContextFromPath(\n  generator: TaskExecutionSchema | undefined,\n  path: string,\n  workspacePath: string\n): Promise<\n  | {\n      path?: string;\n      directory?: string;\n      project?: string;\n      projectName?: string;\n    }\n  | undefined\n> {\n  if (!path) {\n    return;\n  }\n  const project = await getProjectByPath(path, workspacePath);\n  const projectName = (project && project.name) || undefined;\n\n  let modifiedPath = path\n    .replace(workspacePath, '')\n    .replace(/\\\\/g, '/')\n    .replace(/^\\//, '');\n\n  const { workspaceLayout } = await nxWorkspace(workspacePath);\n  const appsDir = workspaceLayout.appsDir;\n  const libsDir = workspaceLayout.libsDir;\n  if (\n    appsDir &&\n    (generator?.name === 'application' ||\n      generator?.name === 'app' ||\n      modifiedPath.startsWith(appsDir))\n  ) {\n    modifiedPath = modifiedPath.replace(appsDir, '').replace(/^\\//, '');\n  }\n  if (\n    libsDir &&\n    (generator?.name === 'library' ||\n      generator?.name === 'lib' ||\n      modifiedPath.startsWith(libsDir))\n  ) {\n    modifiedPath = modifiedPath.replace(libsDir, '').replace(/^\\//, '');\n  }\n\n  return {\n    project: projectName,\n    projectName,\n    path: modifiedPath,\n    ...(!(projectName && generator?.options?.some(isProjectOption)) && {\n      directory: modifiedPath,\n    }),\n  };\n}\n"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","id","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","require","createBuildersAndExecutorsSchema","collections","reduce","acc","collection","schemaRef","platform","path","push","if","properties","builder","const","name","required","then","options","$ref","configurations","additionalProperties","executor","sortWorkspaceProjects","w","sortedProjects","entries","projects","sort","projectA","projectB","localeCompare","fromEntries","hasKey","formatError","message","err","error","stack","toString","async","directoryExists","filePath","stat","isDirectory","_unused","zipOpenFs","ZipOpenFS","libzip","crossFs","PosixFS","fileContents","clearJsonCache","basedir","fullFilePath","readAndCacheJsonFile","json","startsWith","replace","stats","statPromise","_fullFilePath","isFile","content","readFilePromise","JSON","parse","errors","result","parseJson","length","offset","readAndParseJson","packageDetails","packagePath","join","packageName","packageJson","fileExists","PNP_API","getPnpFile","workspacePath","extensions","ext","fileName","pnpFile","pnpApi","pnp","setup","isWorkspaceInPnp","_unused2","pnpDependencyPath","dependencyName","_pnp$resolveToUnquali","resolveToUnqualified","_pnp$resolveVirtual","includes","resolveVirtual","_unused3","workspaceDependencies","nxVersion","dependencies","version","major","packages","values","map","project","root","existingPackages","pkg","localDependencies","resolveRequest","locator","getDependencyTreeRoots","getPackageInformation","packageDependencies","reference","_pkg$packageDependenc","Array","isArray","pnpDependencies","nodeModules","nodeModulesEncapsulated","nodeModulesDir","res","dirContents","readdir","npmPackageOrScope","forEach","p","npmDependencies","workspaceDependencyPath","workspaceDependencyName","nodeModulesPath","encapsulatedPath","findNxPackagePath","buildPath","base","nxWorkspaceDepPath","nrwlWorkspaceDepPath","X_COMPLETION_TYPE","X_COMPLETION_GLOB","CompletionType","hasCompletionType","schema","hasCompletionGlob","implicitDependencies","type","items","outputs","directory","inputs","inputNameWithDeps","input","inputName","fileset","runtime","env","namedInputs","oneOf","tags","enum","targets","executors","assign","dependsOn","targetsWithDeps","target","params","allOf","getProjectJsonSchema","targetDefaults","contents","_ref","targetsSchema","targetsProperties","defaults","targetSchema","match","find","_test$properties","test","else","sourceRoot","createJsonSchema","getPackageJsonSchema","nx","ignore","getNxJsonSchema","Set","projectConfiguration","_projectConfiguration","add","from","getTargets","projectTargets","tasksRunnerOptions","cacheableOperations","current","targetDependencyConfig","description","isPropertyNode","node","isObjectNode","isStringNode","isArrayNode","defaultCompletionMap","Map","getDefaultCompletionType","parent","keyNode","toLowerCase","hasDefaultCompletionType","has","set","glob","completionType","file","projectTarget","log","lspLogger","args","Date","now","toISOString","getNxOutput","logger","importPath","getNxPackage","getNxProjectGraph","getNxWorkspacePackageFileUtils","imported","nxWorkspacePackageJson","projectGraph","getNxWorkspaceConfig","start","performance","readWorkspaceConfigs","process","CI","NX_PROJECT_GLOB_CACHE","NX_WORKSPACE_ROOT_PATH","nxWorkspacePackage","nxProjectGraph","nxOutput","Promise","all","workspaceConfiguration","readWorkspaceConfig","format","exit","console","warn","output","createProjectGraph","createProjectGraphAsync","exitOnError","resetDaemonClient","modifiedWorkspaceConfiguration","projectName","nodes","workspaceProject","_node$data$targets2","_node$data$files2","data","files","_node$data$targets","_node$data$tags","_node$data$files","addProjectTargets","end","_projects","workspaceJson","nxJson","configPath","loadedNxPackage","defaultSemver","SemVer","getNxVersion","coerce","Status","cachedReplay","ReplaySubject","status","not_started","nxWorkspace","reset","resetStatus","firstValueFrom","iif","of","pipe","tap","in_progress","switchMap","_config$workspaceConf","_config$workspaceConf2","config","isLerna","validWorkspaceJson","workspace","daemonEnabled","isEncapsulatedNx","installation","workspaceLayout","appsDir","libsDir","minor","full","npmScope","_workspace","next","cached","createCompletionItem","label","document","kind","documentation","insertText","insertTextFormat","textEdit","newText","range","positionAt","detail","inputNameCompletion","workingPath","hasDependencyHat","_workspace$namedInput","CompletionItemKind","findProjectRoot","child","children","_child$valueNode","valueNode","pathCompletion","supportsInterpolation","searchType","projectRoot","fastGlob","dot","onlyFiles","onlyDirectories","objectMode","completionKind","tagsCompletion","tagCompletion","tag","existingTags","item","getTagsOnCurrentNode","targetsCompletion","targetNames","targetName","_project$targets","existingTargets","getTargetsOnCurrentNode","dependencyHat","getCompletionItems","jsonAst","schemas","position","offsetAt","getNodeFromOffset","completion","projectTargetCompletion","completionItemKind","configuration","_configuration$target","targetLabel","_target$configuration","configurationLabel","projectCompletion","completionItems","resolvedItems","schemaNode","defaultCompletion","existingItems","i","stringify","filter","resolvedItem","createRange","endPosition","Range","languageService","getJsonLanguageService","languageModels","cleanupInterval","nModels","getLanguageModelCache","retrieve","stripSchema","languageId","languageModelInfo","uri","cTime","languageModel","TextDocument","getText","_getJsonLanguageServi","parseJSONDocument","oldestTime","Number","MAX_VALUE","oldestUri","onDocumentRemoved","dispose","clearInterval","findProperty","property","found","setInterval","cutoffTime","cleanupIntervalTimeInSec","uris","tempDocumentCounter","targetLink","targetString","parsedTargets","parseTargetString","baseTargetPath","baseTargetProjectPath","projectJson","readFile","versionNumber","_tempDocumentCounter$","targetNode","targetProperty","configurationNode","findTargetRange","URI","scheme","fragment","line","getHover","hoverParams","hover","doHover","RegExp","isExecutorStringNode","constructExecutorUrl","executorName","split","NxChangeWorkspace","NotificationType","NxWorkspaceRefreshNotification","NxWorkspaceRequest","RequestType","NxGeneratorsRequest","NxGeneratorOptionsRequest","NxProjectByPathRequest","NxGeneratorContextFromPathRequest","NxVersionRequest","NxProjectGraphOutputRequest","NxCreateProjectGraphRequest","getSchemaRequestService","handledSchemas","builtInHandlers","protocol","getContent","location","encoding","c","fs","fsPath","buf","_encoding","xhr","url","followRedirects","headers","response","responseText","reject","getErrorStatusDescription","substr","indexOf","builtInHandler","languageServerWatcher","callback","subscription","watcher","events","some","endsWith","wait","timerId","clearTimeout","setTimeout","debounce","backend","watcherOptions","unsubscribe","listFiles","dirName","readdirSync","statSync","OptionType","GeneratorType","TaskExecutionOutputMessageType","TaskExecutionInputMessageType","isProjectOption","option","_option$$default","$default","$source","normalizeSchema","s","projectDefaults","cliOptions","currentProperty","$defaultIndex","positional","visible","_property$visible","isPropertyVisible","originalName","requiredFields","nxOptions","_option$originalName","xPrompt","workspaceDefault","nxOption","isRequired","isFieldRequired","aliases","alias","default","getItems","tooltip","isLongFormXPrompt","itemTooltips","enumTooltips","isOptionItemLabelValue","getEnumTooltips","optionComparator","compareOptions","legacyCompareOptions","b","getPrio","opt","aPrio","bPrio","IMPORTANT_FIELD_NAMES","IMPORTANT_FIELDS_SET","readCollections","clearPackageJsonCache","allCollections","readCollection","flat","dedupedCollections","singleCollection","collectionNameWithType","executorCollections","generatorCollections","builders","generators","schematics","getCollectionInfo","collectionName","collectionPath","executorCollection","generatorCollection","collectionMap","buildCollectionInfo","schemaPath","dirname","canUse","includeHidden","includeNgAdd","collectionInfo","readCollectionGenerator","extends","extendedSchema","extendedCollections","extended","dependencyPath","Boolean","collectionSchemaName","collectionJson","_collectionJson$alias","generatorType","Application","Library","Other","includeHiddenCollections","includeNgAddCollection","hidden","private","checkAndReadWorkspaceGenerators","workspaceGeneratorType","workspaceGeneratorsPath","collectionDir","f","basename","_schemaJson$json$xTy","_schemaJson$json$desc","schemaJson","schemaJsonPath","$id","readWorkspaceGeneratorsCollection","getGeneratorOptions","generatorName","generatorPath","generatorSchema","workspaceDefaults","collectionDefaults","collectionDefaultsMap","_defaults","_defaults$collectionN","_defaults2","_defaults3","readWorkspaceJsonDefaults","getProjectByPath","selectedPath","relativeFilePath","relative","projectEntries","foundProject","projectConfig","isChildOfRoot","isChildOrEqual","relativeRootConfig","isChildOfRootConfig","findByFilePath","entry","_perfectMatchEntry","perfectMatchEntry","secondaryMatchEntry","fullProjectPath","relativePath","isAbsolute","sep","getProjectGraphOutput","cacheDir","fullPath","normalize","projectGraphOutput","rej","command","displayCommand","encapsulatedNx","useNpx","packageManager","detectPackageManager","cwd","getPackageManagerCommand","exec","getNxExecutionCommand","execSync","windowsHide","stdio","WORKING_PATH","CLIENT_CAPABILITIES","on","connection","unregisterFileWatcher","workspaceContext","resolveRelativePath","resource","substring","lastIndexOf","Utils","createConnection","ProposedFeatures","documents","TextDocuments","listen","onInitialize","_params$initializatio","bind","setLspLogger","initializationOptions","_params$workspaceFold","_params$workspaceFold2","_params$rootUri","workspaceFolders","rootPath","rootUri","capabilities","configureSchemas","reconfigure","sendNotification","method","textDocumentSync","TextDocumentSyncKind","completionProvider","resolveProvider","triggerCharacters","hoverProvider","documentLinkProvider","workDoneProgress","fileOperations","didCreate","filters","pattern","matches","FileOperationPatternKind","didDelete","onCompletion","_await$getJsonLanguag","_getJsonLanguageServi2","ResponseError","changedDocument","completionParams","textDocument","getJsonDocument","completionResults","doComplete","CompletionList","getMatchingSchemas","pathItems","arr1","arr2","apply","onHover","hoverDocument","onDocumentLinks","_getJsonLanguageServi3","linkDocument","links","projectRootPath","linkType","_getDefaultCompletion","DocumentLink","link","getDocumentLinks","jsonDocumentMapper","getExecutors","workspaceSchema","title","architect","getWorkspaceJsonSchema","projectSchema","packageSchema","nxSchema","settings","schemaRequestService","contributions","clientCapabilities","fileMatch","getLanguageService","configure","onDidClose","onShutdown","onRequest","getGenerators","projectPath","generator","_generator$options","modifiedPath","getGeneratorContextFromPath","onNotification","createdFiles","deletedFiles"],"sourceRoot":""}